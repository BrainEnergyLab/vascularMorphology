import ij.IJ;
import ij.measure.Calibration;
import ij.plugin.Duplicator;
import ij.WindowManager;
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.gui.GenericDialog; //Import to allow us to create non blocking dialogs
import ij.plugin.frame.RoiManager;
import ij.gui.Roi;
import ij.plugin.ImageCalculator;
import ij.measure.ResultsTable;
import ij.io.DirectoryChooser; //Import so the user can select a directory from a dialog box
import ij.ImagePlus;
import ij.plugin.ChannelSplitter;
import ij.ImageStack;
import ij.io.FileSaver;

//Function to try all the autoThresh options and get user input after making a small substack of the input image
public static autoThreshTryAll(avg) {

 impDim = avg.getDimensions();
 lowerLim = (impDim[3] * 0.40).intValue();
 upperLim = (impDim[3] * 0.55).intValue();

 //Here we create a 5 slice substack of our smoothed, cleaned image, so that we can try out the auto thresholds on it
 threshTest = new Duplicator().run(avg, lowerLim, upperLim);

 //This runs the try all action for the auto threshold method
 IJ.run(threshTest, "Auto Threshold", "method=[Try all] white stack");
 threshStack = WindowManager.getImage("Stack");

 //These string arrays are for choosing which thresholding method to use
 //Each index in threshChoice corresponds to the method in threshNames
 String[] threshChoice = {
  "1",
  "2",
  "3",
  "4",
  "5",
  "6",
  "7",
  "8",
  "9",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16"
 };

 //Create a non-blocking dialog so the user can still check the image whilst choosing
 //Ask the user which threshold option worked best, and also whether none of them are good
 NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Auto Threshold Choice");
 userInputs.addChoice("Which panel worked the best?", threshChoice, "1");
 userInputs.addCheckbox("Tick if you're not happy with any of the options", false);

 userInputs.showDialog();

 //Close the stack of threshold test
 threshStack.close();

 //Close the threshTest image
 threshTest.close();

 //Get the choices from the dialog box and the associted thresholding method
 int choice = userInputs.getNextChoiceIndex() + 1;

 //Get whether the user is happy with the threshold options 
 goodThreshChoice = userInputs.getCheckboxes().get(0).getState();

 //If the user isn't happy with any of the choices, set the threshold selected to 0
 if (goodThreshChoice == true) {
  choice = 0;
 }

 //Return the thresh selected
 return choice;

}

//This is to replace the image avg with another image backup so that for all variable and title purposes backup is now avg
public static replaceWithBackup(avg, backup) {

 //Get the title of avg, close it without changes, set backup to the same title and reassign it to the avg variable and return it
 avg.changes = false;
 avg.close();
 backup.setTitle(avg.getTitle());
 avg = backup;
 avg.show();

 return avg;
}

public static trialSelectedThreshold(avg, backup, autoThreshFinal) {

 //String of the thresholding methods to use						
 String[] threshNames = {
  "Default",
  "Huang",
  "Huang2",
  "Intermodes",
  "IsoData",
  "Li",
  "MaxEntropy",
  "Mean",
  "MinError(I)",
  "Minimum",
  "Moments",
  "Otsu",
  "Percentile",
  "RenyiEntropy",
  "Shanbhag",
  "Triangle"
 };

 //Create a backup of the image before thresholding the whole thing then creating a composite overlay of the threshold
 //with the raw image to get the user feedback on thresholding quality
 avg.show();
 IJ.run(avg, "Auto Threshold", "method=[" + threshNames[(autoThreshFinal - 1)] + "] white stack");
 IJ.run(avg, "Red", "");
 IJ.run(backup, "Green", "");
 IJ.run(avg, "Merge Channels...", "c1=[" + avg.getTitle() + "] c2=[" + backup.getTitle() + "] create keep");
 comp = IJ.getImage();

 //Ask if the user is happy with threhsolding
 NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Threshold Check");
 userInputs.addCheckbox("Happy with the thresholding?", false);
 userInputs.showDialog();
 goodThreshChoice = userInputs.getCheckboxes().get(0).getState();

 //Close the composite image
 comp.close();

 //Return the user choice on whether the thresholding was good or not
 return goodThreshChoice;

}

//This is to get the user's approval, a simple dialog box with a single check box, and we return the boolean of the checkbox - inputs are just strings for the
//title of the dialog box and the checkbox itself
public static dialogUserApproval(String dialogTitle, String dialogText) {
	
 NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog(dialogTitle);
 userInputs.addCheckbox(dialogText, true);
 userInputs.showDialog();

 //We get a vector of checkbox choices, then get the first checbox choice, then get its state to get the boolean out
 checkboxBoolean = userInputs.getCheckboxes().get(0).getState();

 return checkboxBoolean;
 
}

public static imageEditingFunction(vesselImageProc) {

  //Should add a section here where you can abort the whole thing because if the images aren't good enough for the analysis..
  //Maybe a bit where you can play around with the image yourself?

 //Create a backup of the input image that we can revert to during image processing if we want a clean slate
 babyFresh = vesselImageProc.duplicate();

 //This variable is true as long as we want to keep editing our image
 editImage = true;

 forAnalysis = false;

 //While we want to keep editing
 while (editImage == true) {

  //If the user has press escape during the condition, exit the macro
  if (IJ.escapePressed() == true) {
   System.exit();
  }

  //Show the input image
  vesselImageProc.show();

  //Ask the user to choose between these choices
  String[] choiceArray = {
   "Start from the beginning - remove all image edits",
   "Manually threshold the image",
   "Try an automated thresholding technique",
   "Smooth the image",
   "Despeckle the image",
   "Play around with the image",
   "Abandon this image - move onto the next"
  };

  //Add a section here to play around with the image yourself
  //Also a section to abort the whole image I think and move onto the next one?

  NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Processing");
  userInputs.addChoice("Watchu wanna do 'bout it?", choiceArray, "Start from the beginning - remove all ROI clearances and thresholding");
  userInputs.showDialog();

  int choice = userInputs.getNextChoiceIndex();

  if(forAnalysis == false) {
  	IJ.log("False");
  } else {
  	IJ.log("True");
  }

  if (choice ==6) {
  	IJ.run(vesselImageProc, "Close All", "");
  	editImage = false;
	forAnalysis = false;
  } else if (choice == 5) {
  	
  	backup = vesselImageProc.duplicate();
  	backup.hide();
  	
  	NonBlockingGenericDialog freePlay = new NonBlockingGenericDialog("Freeplay Processing");
  	freePlay.addMessage("Process the image as you see fit");
  	freePlay.addMessage("If you wish to proceed with your processed, thresholded image, rename it \"Processed\"");
  	freePlay.addMessage("Else, leave it named as something else and close all windows except the image");
  	freePlay.addMessage("Press ok when done");
  	freePlay.showDialog();
  	
 	processedImage = WindowManager.getImage("Processed");

 	if(processedImage==null) {
 		backup.show();
 		vesselImageProc = replaceWithBackup(vesselImageProc, backup);
 	} else {
 		backup.close();	
 		
	  	if(processedImage.isInvertedLut() == true) {
			IJ.run(processedImage, "Invert LUT", "");
		}
		
 		vesselImageProc = processedImage;
 		editImage = false;
	 	forAnalysis = true;
 	}

  //If the user wants to despeckle the image
  } else if (choice == 4) {

   //We backup the image, run the despeckle
   backup = vesselImageProc.duplicate();
   IJ.run(vesselImageProc, "Despeckle", "stack");

   backup.show();

   //Check user is happy with despeckling, if so then proceed and close the backup, else revert to backup
   despeckleCheck = dialogUserApproval("Despeckling satisfactory?", "Happy with the despeckle?");

   if (despeckleCheck == true) {
    backup.close();
    IJ.log("Image despeckled");
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user wants to smooth the image
  } else if (choice == 3) {

   //Backup the image
   backup = vesselImageProc.duplicate();

   //Get the user's choices re: smoothing technique and size of smoothing in terms of pixel sizes
   String[] smoothingArray = {
    "Gaussian Blur 3D",
    "Median 3D",
    "Mean 3D",
    "Minimum 3D",
    "Maximum 3D",
    "Variance 3D"
   };
   String[] despeckleArray = {
    "Yes, before smoothing",
    "Yes, after smoothing",
    "No"
   };
   String[] pixelSizeArray = {
    "Pixels to smooth in x: ",
    "Pixels to smooth in y: ",
    "Pixels to smooth in z: "
   };
   ArrayList pixelSizeChoices = new ArrayList();

   NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Smoothing");
   userInputs.addChoice("Which smoothing technique?", smoothingArray, "Gaussian Blur 3D");
   userInputs.addChoice("Do you want to despeckle the image?", despeckleArray, "Yes, before smoothing");

   //Add pixel size fields
   for (fields = 0; fields < pixelSizeArray.length; fields++) {
    userInputs.addNumericField(pixelSizeArray[fields], 0, 0);
   }

   userInputs.showDialog();

   //Get pixel sizes
   for (pxls = 0; pxls < pixelSizeArray.length; pxls++) {
    pixelSizeChoices.add(userInputs.getNextNumber());
   }

   //Get the smoothing method and whether to despeckle before, after, or not
   int smoothingMethod = userInputs.getNextChoiceIndex();
   int despeckleMethod = userInputs.getNextChoiceIndex();

   //If before, run it before smooothing, else run after smoothing
   if (despeckleMethod == 0) {
    IJ.run(vesselImageProc, "Despeckle", "stack");
    IJ.run(vesselImageProc, "" + smoothingArray[smoothingMethod] + "...", "x=" + pixelSizeChoices.get(0) + " y=" + pixelSizeChoices.get(1) + " z=" + pixelSizeChoices.get(2) + "");
   } else if (despeckleMethod == 1) {
    IJ.run(vesselImageProc, "" + smoothingArray[smoothingMethod] + "...", "x=" + pixelSizeChoices.get(0) + " y=" + pixelSizeChoices.get(1) + " z=" + pixelSizeChoices.get(2) + "");
    IJ.run(vesselImageProc, "Despeckle", "stack");
   } else if (despeckleMethod == 2) {
    IJ.run(vesselImageProc, "" + smoothingArray[smoothingMethod] + "...", "x=" + pixelSizeChoices.get(0) + " y=" + pixelSizeChoices.get(1) + " z=" + pixelSizeChoices.get(2) + "");
   }

   //Check user is happy with smoothing, if so then proceed and close the backup, else revert to backup
   smoothFirstCheck = dialogUserApproval("Smoothing satisfactory?", "Happy with the smoothing?");

   if (smoothFirstCheck == true) {
    backup.close();
    IJ.log("Image smoothed using: " + smoothingArray[smoothingMethod]);
    if (despeckleMethod == 1) {
     IJ.log("Image despeckled after smoothing");
    } else if (despeckleMethod == 0) {
     IJ.log("Image despeckled before smoothing");
    }
    IJ.log("Pixel sizes used: " + " x:" + pixelSizeChoices.get(0) + " y:" + pixelSizeChoices.get(1) + " z:" + pixelSizeChoices.get(2));
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user chooses to try an automated thresholding technique
  } else if (choice == 2) {

   //Backup the input image and run the autoThreshTryAll function on the input
   backup = vesselImageProc.duplicate();
   autoThreshFinal = autoThreshTryAll(vesselImageProc);

   //If the user is happy with the threhsolding, then run it (if autothreshfinal is a 0 then the user didn't like any of the outputs)
   if (autoThreshFinal != 0) {

    String[] threshNames = {
     "Default",
     "Huang",
     "Huang2",
     "Intermodes",
     "IsoData",
     "Li",
     "MaxEntropy",
     "Mean",
     "MinError(I)",
     "Minimum",
     "Moments",
     "Otsu",
     "Percentile",
     "RenyiEntropy",
     "Shanbhag",
     "Triangle"
    };
    //Notice here we run it with a stack histogram, not what we do when trying them (seems to mess with how it gets displayed)

    String[] stackOptions = {
     "",
     "use_stack_histogram"
    };
    stackHistogram = dialogUserApproval("Stack Histogram", "Threshold using the stack histogram?");
    int stackChoice = stackHistogram ? 1 : 0;
    IJ.run(vesselImageProc, "Auto Threshold", "method=" + threshNames[(autoThreshFinal - 1)] + " white stack " + stackOptions[stackChoice] + "");

    //Check if the user is happy
    threshFirstCheck = dialogUserApproval("Threshold satisfactory?", "Happy with the threshold?");

    //If so, we try out skeletonising the threhsolded image
    if (threshFirstCheck == true) {

     IJ.log("Proceeding with threshold: " + threshNames[(autoThreshFinal - 1)]);
     editImage = false;
	 forAnalysis = true;
	 backup.close();

     //If the user wasn't happy with thresholding the whole stack, replace the thresholded image with the backup
    } else {
     vesselImageProc = replaceWithBackup(vesselImageProc, backup);
    }
    //Similarly if during the autothrestryall function the user didn't approve anything, then we replace the avg image with the backup	
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user chooses the manually threhsold the image		
  } else if (choice == 1) {

   //Create a backup
   backup = vesselImageProc.duplicate();

   //Run the manual threshlding function on the input where manualHappy is a boolean about whether the user was happy with the manual thresholding
   manualHappy = manualThresholding(vesselImageProc);

   //If the user is happy, we'll try the skeleton editing function
   if (manualHappy == true) {

    editImage = false;
    forAnalysis = true;
    backup.close();

    //If the user wasn't happy with manual thresholding initially, replace the thresholded image with the backup
   } else {
    vesselImageProc = replaceWithBackup(vesselImageProc, backup);
   }

   //If the user wants to start from scratch with the image
  } else if (choice == 0) {

   //Replace the input image with the babyfresh backup and create a new babyfresh backup
   vesselImageProc = replaceWithBackup(vesselImageProc, babyFresh);
   babyFresh = vesselImageProc.duplicate();
   IJ.log("Removing all image edits and starting from scratch");
  }

 }

 ArrayList outputs = new ArrayList();
 outputs.add(vesselImageProc);
 outputs.add(forAnalysis);

 return outputs;

}

//Ask the user to select the directory where the isolectin images to be analysed are
DirectoryChooser userDir = new DirectoryChooser("Select The Isolectin Directory");

//Create a tring to store a choice of channels
String[] channelSelection = {
 "1",
 "2",
 "3",
 "4"
};

//Ask the user to choose which channels represent the vessels and isolectin staining
GenericDialog userInput = new GenericDialog("Channel Selection");
userInput.addChoice("Which channel are the vessels in?", channelSelection, "1");
userInput.addChoice("Which channel is Isolectin in?", channelSelection, "2");
userInput.showDialog();

//Get the isolectin directory and its contained files/folders
String dirString = userDir.getDirectory();
File dir = new File(dirString);
String[] folderList = dir.list();

//Get channels chosen by the user
int[] channelNumbs = new int[2];
//[0] is vesselChannel, [1] is isoChannel

for (i = 0; i < 2; i++) {
 channelNumbs[i] = userInput.getNextChoiceIndex() + 1;
}

//Looping through the isolectin directory files/folders
for (i = 0; i < folderList.length; i++) {

 //Concatenate the file onto the original isolectin directory
 String fullString = dirString.concat(folderList[i]);
 File currFile = new File(fullString);

 //If this is a directory and if it contains an M then get the list of files in that folder
 if (currFile.isDirectory() == true && folderList[i].contains("M")) {
  String[] imagesRaw = currFile.list();

  //Looping through those files
  for (j = 0; j < imagesRaw.length; j++) {

   //Create a variable where we store the directory to check if the image has already been processed
   File processed = fullString + "/" + "Processed/" + imagesRaw[j] + "/";
   
   //If the image doesn't contain zproject or lif in its name and it hasn't been processed						//Need to add a condition here for user choice over whether to threshold or process images - same for later too
   if (!imagesRaw[j].contains("zproject") && !imagesRaw[j].contains("lif") && !File.exists(processed)) {

    //Print the image name, open it, get its calibration, and if it hasn't been calibrated, ask the user to do so
    String imagePath = fullString + "/" + imagesRaw[j];
    raw = IJ.openImage(imagePath);
    Calibration rawCal = raw.getCalibration();
    while (!rawCal.getUnit().equals("micron")) {
     new WaitForUserDialog("Image Calibration", "Calibrate the image in microns").show();
    }

    //Get out the number of slices we'd need for a 40um thick substack of the tissue, as well as the number
    //of slices in the image, then calculate the substack we need to make to take out the middle 40um of the image
    double slicesToGrab = rawCal.getRawZ(40);
    double rawSlices = (double) raw.getNSlices();
    double beginningPoint = Math.floor((rawSlices - slicesToGrab) / 2);

    //Create a substack based on those numbers and close the raw image
    cutDown = new Duplicator().run(raw, 1, raw.getNChannels(), (int) beginningPoint, (int)(rawSlices - beginningPoint), 1, 1);
    raw.close();

    //Create arrays to store the image stacks of the split channels and then the imageplus objects we make from the stacks,
    //as well as the titles we want to stick onto our imageplus objects
    ImageStack[] imageStacks = new ImageStack[2];
    ImagePlus[] images = new ImagePlus[2];
    //[0] is vesselImage, [1] is isoImage
    String[] titles = new String[] {
     "Vessels",
     "Iso"
    };

    //Create an imageplus array to store our processed imageplus objects
    ImagePlus[] procImages = new ImagePlus[2];

    for (k = 0; k < 2; k++) {
     imageStacks[k] = new ChannelSplitter().getChannel(cutDown, channelNumbs[k]);
     images[k] = new ImagePlus(titles[k], imageStacks[k]);
     
    }

	//Close our original cutDown image
    cutDown.close();

    //Assign variable names to the processed images
    vesselImageProc = images[0];
    isoImageProc = images[1];

	//Run the imageEditingFunction on our vessel image, and get out whether it was successful or not
    vesselImageOutput = imageEditingFunction(vesselImageProc);

	//If it wasn't successful, close all the images, create the processed directory (so that we know we've processed this image)
	//and move onto the next image
	if(vesselImageOutput.get(1) == false) {
		IJ.run(vesselImageProc, "Close All", "");
    	processed.mkdirs();
		continue;
	}

	//If it was successful, get the image it generated
	vesselImageProc = vesselImageOutput.get(0);

    //Run the imageEditingFunction on our iso image, and get out whether it was successful or not
    isoImageOutput = imageEditingFunction(isoImageProc);

	//If it wasn't successful, close all the images, create the processed directory (so that we know we've processed this image)
	//and move onto the next image
    if(isoImageOutput.get(1) == false) {
    	IJ.run(isoImageProc, "Close All", "");
    	processed.mkdirs();
    	continue;
    }

	//If it was successful, get the image it generated
    isoImageProc = isoImageOutput.get(0);

	//Create a FileSaver object to save our processed images with the names in the saveName string array
	FileSaver[] imageSave = new FileSaver[] { vesselImageProc, isoImageProc};
	String[] saveName = new String[] {"Processed Vessels", "Processed Iso"};

	//Create the directory where we will save our processed images
	processed.mkdirs();

	//Save our images in the processed directory
    for(k=0; k<imageSave.length; k++) {
    	imageSave[k].saveAsTiff(processed.getPath() + saveName[k]);
    }

	//Close all images before proceeding to the next image in the directory
    IJ.run(vesselImageProc, "Close All", "");

   }
  }

  //Loop through all the images in the folder again
  for(j=0; j<imagesRaw.length; j++) {
  	
    //Create a variable where we store the directory to check if the image has actually been processed
    File processed = fullString + "/" + "Processed/" + imagesRaw[j] + "/Processed Vessels.tif"

	//If the file has been processed
	if(File.exists(processed)) {
	
	 //Open the vessel and iso images
     vesselImageProc = IJ.openImage(processed.getPath() + ".tif");
     isoImageProc = IJ.openImage(processed.getParent() + "/Processed Iso.tif");

	 //Create an imageplus array to store duplicates of the vesselImageProc object, and a string array to store the
	 //names we'll call these duplicates
     ImagePlus[] duplicates = new ImagePlus[2];
     String[] titles = new String[] {
      "Skel",
      "DmapPre"
     };

	//Duplicate the image and set its titles
    for (l = 0; l < 2; l++) {
     duplicates[l] = vesselImageProc.duplicate();
     duplicates[l].setTitle(titles[l]);
    }

	//Set objects to these duplicates
	dmapPre = duplicates[1];
	skeleton = duplicates[0];

    dmapPre.show();

    //Generate the distance map
    IJ.run("3D Distance Map", "map=EDT image=" + dmapPre.getTitle() + " mask=None threshold=1");
    dmap = IJ.getImage();
    dmap.setTitle("dmap");

    //Close the image used to generate it
    dmapPre.changes = false;
    dmapPre.close();

    //Skeletonise the image
    IJ.run(skeleton, "Skeletonize (2D/3D)", "");

    IJ.log("Getting out number of objects in the picture");

    //Use the 3D manager (within a macro as commands don't work otherwise) to segment our vessels and get out the number of objects in the picture
    output = IJ.runMacro("run(\"3D Manager\"); selectWindow(\"Thresholded\"); Ext.Manager3D_Segment(1,255); Ext.Manager3D_AddImage(); Ext.Manager3D_Count(nb_obj); Ext.Manager3D_Close(); textForm = toString(nb_obj); return textForm;");
    nbObj = Integer.valueOf(output);
    segmentedImage = WindowManager.getImage("Thresholded-3Dseg");

    IJ.log("Number of objects: " + output);

    //Create a new results table to store our info
    customRT = new ResultsTable();

    //Loop through our objects
    for (i = 0; i < nbObj; i++) {

     IJ.log("Analysing object number: " + Integer.toString(i));
     
     //Get out each part of the segmented image, find where the current section overlaps with the skeleton
     //to get its skeleton bit
     segmentedImage.show();
     IJ.run(segmentedImage, "Select Label(s)", "label(s)=" + (i + 1) + "");
     labelImage = IJ.getImage();
     ImageCalculator ic = new ImageCalculator();
     imp3 = ic.run("AND create stack", skeleton, labelImage);
     imp3.show();
     imp3.setTitle("Result");
     skeleton.hide();
     labelImage.hide();

	 IJ.log("Getting radius of object");

     //Use the skeleton of it to read out the radius of the section in our distance map
     output = IJ.runMacro("setBatchMode(true); saveDir = File.directory + \"Roi.zip\"; print(saveDir); run(\"3D Manager\"); selectWindow(\"Result\"); Ext.Manager3D_AddImage(); Ext.Manager3D_Save(saveDir); Ext.Manager3D_Close(); run(\"3D Manager\"); Ext.Manager3D_Load(saveDir);  selectWindow(\"dmap\"); Ext.Manager3D_Quantif3D(0, \"Mean\", quantif); Ext.Manager3D_Close(); textForm = toString(quantif); return textForm;");
     meanValue = Double.valueOf(output);

     IJ.log("Radius is " + output);
     IJ.log("Getting skeleton length of object");

     //Get out the volume in pixels of the skeleton (length)
     output = IJ.runMacro("setBatchMode(true); saveDir = File.directory + File.separator + \"Roi.zip\"; run(\"3D Manager\"); Ext.Manager3D_Load(saveDir); Ext.Manager3D_Measure3D(0, \"Vol\", vol); asString = toString(vol); print(asString); Ext.Manager3D_Close(); return asString;");
     length = Double.valueOf(output);

     IJ.log("Length in pixels is " + output);

     //Close the result image
     imp3.close();

     IJ.log("Enlarging object by 2 microns");

     //Create an enlarged image that is enlarged by 2 microns around the segment so we can use this as a ROI to look for our isolectin staining
     enlargedImage = labelImage.duplicate();
     
     IJ.run(enlargedImage, "Maximum 3D...", "x=" + rawCal.getRawX(2.0) + " y=" + rawCal.getRawY(2.0) + " z=" + rawCal.getRawZ(2.0) + "");
     labelImage.show();
	 
     diffImage = ic.run("Difference create stack", enlargedImage, labelImage);
     diffImage.show();
     diffImage.setTitle("Diff");

     IJ.log("Finding volume of enlarged object");

     //Use this image to get out to the volume that we're checking for overlap within
     output = IJ.runMacro("setBatchMode(true); run(\"3D Manager\"); selectWindow(\"Diff\"); Ext.Manager3D_AddImage(); Ext.Manager3D_Measure3D(0, \"Vol\", measure); Ext.Manager3D_Close(); asString = toString(measure); return asString;");
     volumeChecking = Double.valueOf(output);

     IJ.log("Volume of enlarged object: " + output);

     enlargedImage.close();
     labelImage.close();

     IJ.log("Finding pixels from isolectin within our ROI");

     //Calculate the isolectin staining that is within our ROI to check
     ImageCalculator ic = new ImageCalculator();
     IB4Overlap = ic.run("AND create stack", isoImageProc, diffImage);
     IB4Overlap.show();
     IB4Overlap.setTitle("IB4Overlap");

	 IJ.log("Getting volume of pixels within ROI");

     //Use the 3D manager to get out the volume within this ROI
     output = IJ.runMacro("setBatchMode(true); selectWindow(\"IB4Overlap\"); run(\"Auto Threshold\", \"method=Default white stack\"); run(\"Z Project...\", \"projection=[Max Intensity]\"); selectWindow(\"MAX_IB4Overlap\"); run(\"Invert\", \"stack\");  run(\"Create Selection\"); print(\"Selection\" + selectionType()); if(selectionType() == -1) { run(\"Select None\"); asString = \"0\"; run(\"Invert\", \"stack\"); selectWindow(\"MAX_IB4Overlap\"); run(\"Close\"); return asString; } else {  selectWindow(\"MAX_IB4Overlap\"); run(\"Close\"); selectWindow(\"IB4Overlap\"); run(\"Select None\"); run(\"3D Manager\"); Ext.Manager3D_AddImage();  Ext.Manager3D_Measure3D(0, \"Vol\", measure); Ext.Manager3D_Close(); asString = toString(measure); return asString;");
     overlappingVolume = Double.valueOf(output);

     IJ.log("Overlapping pixels: " + output);

     IB4Overlap.changes = false;
     IB4Overlap.close();
     diffImage.close();

     //Fill our results table with the values of interest
     customRT.setValue("Radii", i, meanValue);
     customRT.setValue("Length", i, length);
     customRT.setValue("Volume Around", i, volumeChecking);
     customRT.setValue("Volume Occupied", i, overlappingVolume);
     customRT.setValue("Percentage Occupied", i, overlappingVolume / volumeChecking);

     customRT.show("Testing");

    }

    //Save as a results table labelled with the same name as our image
    customRT.save(processed.getParent() + "/IB4Overlap.xls");
    customRT.reset();

    IJ.log("Results saved");

    //Close all our windows
    IJ.run(vesselImageProc, "Close All", "");

   }
  }
 }
}
