import ij.IJ; //Import this so that we can use imageJ to open the image
import ij.gui.GenericDialog; //Import so we can create dialog boxes
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.ImagePlus; //Import to allow us to create or alter images
import ij.WindowManager; //Import to allow us to manager windows
import ij.measure; //Import so we can measure things
import ij.macro.Variable; //Import so we can use the variable type
import ij.measure.Calibration; //Import so we can access and set calibration values
import ij.measure.ResultsTable; //Import so we can access the results table
import ij.plugin.Duplicator; //Import so we can create substacks using the duplicator
import ij.process.ImageProcessor; //Import so we can invert the LUT after thresholding
import ij.plugin.PlugIn; //Import so we can save things without prompting to save changes
import ij.plugin.frame.RoiManager; //Import so we can work with the roi manager
import ij.io.DirectoryChooser; //Import so the user can select a directory from a dialog box
import ij.gui.PointRoi; //import so we can make point ROIs

//Import these so we can use analyze skeleton
import sc.fiji.analyzeSkeleton.AnalyzeSkeleton_;
import sc.fiji.analyzeSkeleton.Edge;
import sc.fiji.analyzeSkeleton.Point;


avg = WindowManager.getImage("skeletonisedImage.tif");
dmap = WindowManager.getImage("Dmap.tif");

double[] pixelSizeArray = {1.4844, 1.4844, 2.0};
//[0] is xPixelSize, [1] is yPixelSize, [2] is zPixlSize

double[] imageDimensions = {512, 512, 151};
//[0] is width, [1] is height, [2] is slices

//Calculate the volume of the image in calibrated units
avgVolume=1;
for(i=0; i<imageDimensions.length; i++) {
	avgVolume = imageDimensions[i] * pixelSizeArray[i] * avgVolume;
}

double volumeRemoved=100;

//Here we define a class skeletonValues that will contain the radius, skeleton, branch, and coordinate number for each coordinate in our skeleton - we do this so we can sort this data
//by skeleton, then branch, then coordinate number, so that it matches our skeleton coordinate data so we simply have to append our radius to that data rather than search that data
//to find which coords the radius belongs to

//All this sorting code was adapted from http://techthinking.net/2010/04/how-to-sort-two-dimensional-data-based-on-multiple-parameters/
class skeletonValues {

	//define skelValues as a double array of size 10, where each index corresponds to the values outlined in the finalTableHeadings array
	//String[] finalTableHeadings = {"Radius", "X Cal", "Y Cal", "Z Cal", "X Coord", "Y Coord", "Z Coord", "Skel No.", "Branch No.", "Coord No"};
	double[] skelValues = new double[10];

	//Here a skeletonValues object contains the skelValues double array, so each skelValues object has 10 data points, and we define how to get our the radius, skelNo, branchNo, and coordNo from this data
	public skeletonValues(double[] skelValues) {
		super();
		this.radius = skelValues[0];
		this.skelNo = skelValues[7];
		this.branchNo = skelValues[8];
		this.coordNo = skelValues[9];
	}
}

//This creates a comparator object that returns whether the skeletonvalues at two skeletonValues points (a1 and a2) are different or equal by altering the returned int accordingly
static final Comparator ORDER_BY_SKELNAME = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.skelNo<a2.skelNo) {
			return -1;
		} else if (a1.skelNo>a2.skelNo) {
			return 1;
		} else if (a1.skelNo == a2.skelNo) {
			return 0;
		}
	}
};

//Comparator to compare a1 and a2 on branch number
static final Comparator ORDER_BY_BRANCHNO = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.branchNo<a2.branchNo) {
			return -1;
		} else if (a1.branchNo>a2.branchNo) {
			return 1;
		} else if (a1.branchNo == a2.branchNo) {
			return 0;
		}
	}
};

//Comparator to compare coord numbers between a1 and a2
static final Comparator ORDER_BY_COORD = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.coordNo<a2.coordNo) {
			return -1;
		} else if (a1.coordNo>a2.coordNo) {
			return 1;
		} else if (a1.coordNo == a2.coordNo) {
			return 0;
		}
	}
};

//This creates a final comparator which is a summary of the comparators we've previously defined - essentially, if skelNo matches, we order by branchNo, if that matches we order by Coord, else we stop at whichever
//step the values don't match

//The reason we're using comparators here is so we can use Arrays.sort(T[] a, Comparator<? super T> c) where we can input an array and then use a comparator to sort it - the ORDER_BY_RULES comparator is
//essentially a summary of all the others and so allows us to sort by multiple columns
static final Comparator ORDER_BY_RULES = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		int i = ORDER_BY_SKELNAME.compare(a1,a2);
		if(i == 0){
			i = ORDER_BY_BRANCHNO.compare(a1,a2);
			if(i == 0){
				i = ORDER_BY_COORD.compare(a1,a2);
			}
		}
		return i;
	}
};

//Make sure there are no selections on the skeleton image
IJ.run(avg, "Select None", "");
	
// analyze skeleton
skel = new AnalyzeSkeleton_();
skel.setup("", avg);
skelResult = skel.run(AnalyzeSkeleton_.NONE, false, false, null, true, false);
	
// get graphs (one per skeleton in the image)
graph = skelResult.getGraph();
	
//Create 2D arraylist to store the x, y, and z coordinates of each voxel, as well as their associated skeleton number, branch number, and coord number and their calibrated values

ArrayList[][] table = new ArrayList[3][3];
//[0][0] is xCoords, [0][1] is yCoords, [0][2] is zCoords
//[1][0] is xCoordsCal, [1][1] is yCoordsCal, [1][2] is zCoordsCal
//[2][0] is skeletonNo, [2][1] is branchNo, [2][2] is coordNo

//Fill table with arrayLists
for(i=0; i<3; i++) {
	for(j=0; j<3; j++) {
		table[i][j] = new ArrayList();
	}
}

	
// go through all skeletons
for(i=0 ; i < graph.length; i++ ) {
	listEdges = graph[i].getEdges(); 
	
	// go through all branches - j counts how many branches for each skeleton, our results table won't show data for skeletons without branches or coords
	j=1;
	for( Edge e : listEdges ) {	
		
		//Get the coords of the starting point
		p1 = e.getV1().getPoints().get( 0 );
		
		//no points is how many coordinates we've collected in this branch
		noPoints = 1;

		//Create a double array to store the x, y, and z coordinates of the p1 point and one to store the skeleton number, branch number, and coordinate number (all starting from 1)
		double[] pixelCoords = {p1.x, p1.y, p1.z};
		double[] skelInfo = {((double) (i+1)), ((double) j),((double) noPoints)};
		
		//Loop through the columns and rows of the 2d arraylist table - if in the first column, we're adding the raw coordinates, if the second, we're adding the calibrated coordinates,
		//and if the third, we're adding the skeleton, branch, and coordinate info
		for(columnAdding = 0; columnAdding<3; columnAdding++) {
			for(rowAdding=0; rowAdding<3; rowAdding++) {
				if(columnAdding==0) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]);
				} else if (columnAdding==1) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]*pixelSizeArray[rowAdding]);
				} else if (columnAdding ==2) {
					table[columnAdding][rowAdding].add(skelInfo[rowAdding]);
				}
			}
		}

		//Increase our count of coordinates
		noPoints++;	
		
		//Get coords for all points between starting and end coords
		for( Point p : e.getSlabs() ) {		  			
			
			//Same story here with the arrays and loop to add the arrays
			double[] pixelCoords = {p.x, p.y, p.z};
			double[] skelInfo = {((double) (i+1)), ((double) j),((double) noPoints)};
			for(columnAdding = 0; columnAdding<3; columnAdding++) {
				for(rowAdding=0; rowAdding<3; rowAdding++) {
					if(columnAdding==0) {
						table[columnAdding][rowAdding].add(pixelCoords[rowAdding]);
					} else if (columnAdding==1) {
						table[columnAdding][rowAdding].add(pixelCoords[rowAdding]*pixelSizeArray[rowAdding]);
					} else if (columnAdding ==2) {
						table[columnAdding][rowAdding].add(skelInfo[rowAdding]);
					}
				}
			}
			noPoints++;	
		}	
		
		//Get final coord points
		p2 = e.getV2().getPoints().get( 0 );

		//Same story here
		double[] pixelCoords = {p2.x, p2.y, p2.z};
		double[] skelInfo = {((double) (i+1)), ((double) j),((double) noPoints)};
		for(columnAdding = 0; columnAdding<3; columnAdding++) {
			for(rowAdding=0; rowAdding<3; rowAdding++) {
				if(columnAdding==0) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]);
				} else if (columnAdding==1) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]*pixelSizeArray[rowAdding]);
				} else if (columnAdding ==2) {
					table[columnAdding][rowAdding].add(skelInfo[rowAdding]);
				}
			}
		}
		
		//As this is the final point in the branch, we increase branch number
		j++;
	}
}

//Create a 3D double array to store the data in the table arrayList (convert from arrayList to double array)
double[][][] valueStore = new double[3][3][];
//[0][0] is xCoords, [0][1] is yCoords, [0][2] is zCoords
//[1][0] is xCoordsCal, [1][1] is yCoordsCal, [1][2] is zCoordsCal
//[2][0] is skeletonNo, [2][1] is branchNo, [2][2] is coordNo

//Create a 2D string array to store the labels for our values in our valueStore array
String[][] tableHeaders = {{"xCoords", "yCoords", "zCoords"}, {"xCoordsCal", "yCoordsCal", "zCoordsCal"}, {"Skeleton Number", "Branch Number", "Coordinate Number"}};

//Loop through the columns and rows, creating the right sized arrays in the third dimension according to the sizes in the arraylist table
for(j = 0; j<3; j++) {
	for(k =0; k<3; k++) {
		valueStore[j][k] =  new double[table[j][k].size()];
	}
}	

//Create a new results table to store the 3d coordinate data
rt = new ResultsTable();	

//Go through all the table columns and rows, and fill the correct index in our valueStore array with the table value, making sure we cast it as a double - also fill our results table with the data
for(columnAdding = 0; columnAdding<3; columnAdding++) {
	for(rowAdding=0; rowAdding<3; rowAdding++) {
		for(thirdD = 0; thirdD<table[columnAdding][rowAdding].size(); thirdD++) {
			valueStore[columnAdding][rowAdding][thirdD] = (double) table[columnAdding][rowAdding].get(thirdD);
			rt.setValue(tableHeaders[columnAdding][rowAdding], thirdD, valueStore[columnAdding][rowAdding][thirdD]);
		}
	}
}

//Run analyze skeleton so we can get out the branch length and euclidean distance of all the skeleton branches
IJ.run(avg, "Analyze Skeleton (2D/3D)", "prune=[shortest branch] show");

//Get the results table, close it, then set the branch information table as the results table, and get its object reference

currResults = WindowManager.getWindow("Results");
currResults.dispose();
IJ.renameResults("Branch information", "Results");
ResultsTable branchInfo = ResultsTable.getResultsTable();


//Here we create a double array to store the skeleton number, branch distance, and euclidean distance, from the branch info results table - we also create an int array to store the indices of
//these columns in the table
double [][] branchInfoColumns = new double[4][];
int[] branchInfoIndices = {0,1,8}; 
//[0] is skelId, [1] is branch length, [2] is euclidean distance, [3] is for storing the branch number that we calculate 

//Loop through, getting the 3 columns from the table and storing them in our 2d double array
for(i=0; i<3; i++) {
	branchInfoColumns[i] = branchInfo.getColumnAsDoubles(branchInfoIndices[i]);
}

//Create a double value that counts how many branches there are for each skeleton, cast as a double so we can put it into a results table, and 
double currentNo = 1;

//Maybe store our branch number values in a new array, rather than setting it in a results tables

//Loop through all the skeleton values, if we're at the first one, we set the branch number as 1, else we check how the current skeleton compares to the previous one, and if they're teh same,
//we increase our branch number, otherwise we reset to 1, and store it in our branchInfoColumns [3] array
for(skelIndex=0; skelIndex<branchInfoColumns[0].length; skelIndex++) {
	if(skelIndex==0) {
		branchInfoColumns[3][skelIndex] = currentNo;
	} else {
		if(skelID[skelIndex] == skelID[skelIndex-1]) {
			currentNo = currentNo+1;
		} else {
			currentNo = 1;
		}
		branchInfoColumns[3][skelIndex] = currentNo;
	}
}

if(false) {

//Create new 2D double arrays to work with the diameter data
double[][] diameterSetting = new double[6][];
double[][] diameterGetting = new double[6][];
//[0] to [2] are the x, y, and z coords, [3] to [5] are the skel, branch, and coord numbers

int[] columnIndices = {0,1,2,6,7,8};

for(i=0; i<columnIndices.length; i++) {
	diameterGetting[i] = hereye.getColumnAsDoubles(columnIndices[i]);
	diameterSetting[i] = new double[diameterGetting[i].length];
}

}

//Set the measurements we're making to calculate the mean
IJ.run("Set Measurements...", "mean redirect=None decimal=9");

//Run the roi manager so we have somewhere to place our multipoint selections and get its reference, and get out the number of slices in our image
IJ.run("ROI Manager...", "");
RoiManager manager = RoiManager.getInstance();
imageSlices = dmap.getNSlices();

ArrayList[] newTable = new ArrayList[6];
//[0] is x coord, [1] is y, [2] is z, [3] is skel, [4] is branch, [5] is coord

for(j=0; j<6; j++) {
	newTable[j] = new ArrayList();
}

finalTable = new ResultsTable();
String[] finalTableHeadings = {"Radius", "X Cal", "Y Cal", "Z Cal", "X Coord", "Y Coord", "Z Coord", "Skel No.", "Branch No.", "Coord No"};


//Create a 3D double array to store the data in the table arrayList (convert from arrayList to double array)
double[][][] valueStore = new double[3][3][];
//[0][0] is xCoords, [0][1] is yCoords, [0][2] is zCoords
//[1][0] is xCoordsCal, [1][1] is yCoordsCal, [1][2] is zCoordsCal
//[2][0] is skeletonNo, [2][1] is branchNo, [2][2] is coordNo

//Loop through all the slices in our distance map, setting the image to that slice each time
for(i=1; i<imageSlices+1; i++) {		
	dmap.setSlice(i);

	//Create an arraylist array to store the x and y values we want to use to make our multipoint selections
	ArrayList[] xandyLists = new ArrayList[2];
	
	for(i0=0; i0<valueStore[0].length; i0++) {
		int zIntCurr = (int) valueStore[0][2][i0] + 1;
		if(zIntCurr == i) {				
			for(j=0; j<6; j++) {
				newTable[j].add(diameterGetting[j][i0]);
				if(j<2) {
					xandyLists[j].add(diameterGetting[j][i0]);
				}
			}	
		}
	}

	int[][] xandyArrays = new int[2][];

	for(i0=0; i0<2; i0++) {
		test = xandyLists[i0].toArray();
		int[] testing = new int[test.length];
		for(i1 = 0; i1<test.length; i1++) {
			testing[i1] = (int) test[i1];
		}
		xandyArrays[i0] = testing;
	}	

	pointRoi = new PointRoi(xandyArrays[0], xandyArrays[1], xandyArrays[0].length);	
	IJ.run(dmap, "Select None", "");
	
	dmap.setRoi(pointRoi);
	manager.addRoi(pointRoi);
	WindowManager.setTempCurrentImage(dmap);
	manager.runCommand("Deselect");
	manager.runCommand("Measure");
	manager.runCommand("Deselect");
	manager.runCommand("Delete");

	IJ.run(dmap, "Select None", "");
}

ResultsTable newResultsTable = ResultsTable.getResultsTable();		
finalSize = newResultsTable.size();
				
String[] newResultsTableColumnsToGet = {"Mean", "X", "Y", "Slice"};

for(i0=0; i0< finalSize; i0++) {	
	for(i1=0; i1<finalTableHeadings.length; i1++) {
		if(i1<3) {
			finalTable.setValue(finalTableHeadings[i1], i0, newResultsTable.getValue(newResultsTableColumnsToGet[i1], i0));
		} else if (i1==3) {
			finalTable.setValue(finalTableHeadings[i1], i0, (newResultsTable.getValue(newResultsTableColumnsToGet[i1], i0)-1)*pixelSizeArray[2]);
		} else if (i1>3) {
			finalTable.setValue(finalTableHeadings[i1], i0, newTable[(i1-4)].get(i0));
		}
	}
}

finalTable.show("Results");

double[][] finalTableArrays = new double[finalTableHeadings.length][];
double[][] rtTableArrays = new double[10][];

//ArrayList[] finalTableLists = new ArrayList[finalTableHeadings.length];

//make this work with skeldata...

for(i=0; i<finalTableHeadings.length; i++) {
	finalTableArrays[i] = finalTable.getColumnAsDoubles(i);
	//finalTableLists[i] = new ArrayList();
	//finalTableLists[i].add(finalTableArrays[i]);
}

for(i=0; i<10; i++) {
	if(i<9) {
		rtTableArrays[i] = rt.getColumnAsDoubles(i);
	} else {
		rtTableArrays[i] = new double[rtTableArrays[0].length];
	}
	
}


//Address Class


skeletonValues[] radiiTable = new skeletonValues[finalTableArrays[0].length];
double[] skeletonValuesToUse = new double[10];

for(i=0; i<finalTableArrays[0].length; i++) {
	for(i0=0; i0<10; i0++) {
		skeletonValuesToUse[i0] = finalTableArrays[i0][i];
	}
	radiiTable[i] = new skeletonValues(skeletonValuesToUse);
	//radiiTable[i] = new skeletonValues(finalTableArrays[0][i], finalTableArrays[1][i], finalTableArrays[2][i], finalTableArrays[3][i], finalTableArrays[4][i], finalTableArrays[5][i], finalTableArrays[6][i], finalTableArrays[7][i], finalTableArrays[8][i], finalTableArrays[9][i]);
}

Arrays.sort(radiiTable, ORDER_BY_RULES);

for(i=0; i<finalTableArrays[0].length; i++) {
	rt.setValue("Radius", i, (double) radiiTable[i].radius);
	rt.setValue("Apparant Skel", i, (double) radiiTable[i].skelNo);
	rt.setValue("Apparant Branch", i, (double) radiiTable[i].branchNo);
	rt.setValue("Apparant Coords", i, (double) radiiTable[i].coordNo);
}

rt.show("Matching Radii");

String[] rtTableHeadings = {"xCoords", "yCoords", "zCoords", "xCoordsCal", "yCoordsCals", "zCoordsCal", "Skeleton Number", "Branch Number", "Coordinate Number", "Radius", "Apparant Skel", "Apparant Branch", "Apparant Coords"};

ArrayList [] rtTableGetting = new ArrayList[4];
double[][] rtTableSetting = new double[3][];
//[0] is totalRadii, [1] is skel, [2] is branch

int[] rtTableIndices = {6,7,9};

for(i=0; i<4; i++) {
	rtTableGetting[i] = new ArrayList();
	if(i<3) {
	rtTableSetting[i] = rt.getColumnAsDoubles(rtTableIndices[i]);
	}
}

double[] prevValues = new double[3];
double[] currentValues = new double[3];
//[0] is skel, [1] is branch, [2] is radii

double[] valuesToAdd = new double[4];
//[0] is average radius, [1] is prevSkel, [2] is prevBranch, [3] is noCoords

//Need to work on this - make sure we're getting the right radii summaries for each branch points

double runningTotal=0;

for(i=1; i<finalTableArrays[0].length+1; i++) {
				
	for(i0=0; i0<rtTableIndices.length; i0++) {
		prevValues[i0] = rtTableSetting[i0][i-1];
		currentValues[i0] = rtTableSetting[i0][i];
		//IJ.log(IJ.d2s(prevValues[i0],9));
		//IJ.log(IJ.d2s(currentValues[i0],9));
	}

	runningTotal = runningTotal + prevValues[2];
	
	//IJ.log(IJ.d2s(runningTotal,9) + " " + IJ.d2s(prevValues[2],9));

	valuesToAdd[1] = prevValues[0];
	valuesToAdd[2] = prevValues[1];

	//IJ.log(IJ.d2s(prevValues[0], 9) + " " + IJ.d2s(currentValues[0], 9) + " " + IJ.d2s(prevValues[1], 9) + " " + IJ.d2s(currentValues[1], 9));
						
	if (prevValues[0] != currentValues[0] || prevValues[1] != currentValues[1]) {

		noCoords = rtTableArrays[8][i-1];
		valuesToAdd[0] = runningTotal/noCoords;
		valuesToAdd[3] = noCoords;

		//IJ.log(IJ.d2s(runningTotal/noCoords,9) + " " + IJ.d2s(runningTotal,9) + " " + IJ.d2s(noCoords,9));
		
		for(i0=0; i0<4; i0++) {
			rtTableGetting[i0].add(valuesToAdd[i0]);
			//IJ.log(IJ.d2s(valuesToAdd[i0], 9));
		}
						
		runningTotal = 0;
	}

				
}

//radius and distances are already calibrated

averageRadius = rtTableGetting[0].toArray();
prevSkel = rtTableGetting[1].toArray();
prevBranch = rtTableGetting[2].toArray();
prevCoords = rtTableGetting[3].toArray();

for(i=0; i<averageRadius.length; i++) {
	newBranchInfo.setValue("Radius", i, averageRadius[i]);
	newBranchInfo.setValue("prevSkel", i, prevSkel[i]);
	newBranchInfo.setValue("prevBranch", i, prevBranch[i]);
	newBranchInfo.setValue("no coords", i, prevCoords[i]);
}

newBranchInfo.show("Final table");
System.exit();

double[][] newBranchInfoColumns = new double[2][];
//[0] is skel, [1] is branch no.

for(i=0; i<2; i++) {
	newBranchInfoColumns[i] = newBranchInfo.getColumnAsDoubles(i);
}

ArrayList radiiValues = new ArrayList();

for(x=0; x<newBranchInfoColumns[0].length; x++) {	
	skelToFind = newBranchInfoColumns[0][x];
	branchToFind = newBranchInfoColumns[1][x];
	//IJ.log("xToFind: " + IJ.d2s(skelToFind) + " yToFind " + IJ.d2s(branchToFind));
	for(xRef=0; xRef<averageRadius.length; xRef++) {
		if(prevSkel[xRef] == skelToFind && prevBranch[xRef] == branchToFind) {
			radiusValue = averageRadius[xRef];
			radiiValues.add(radiusValue);
			IJ.log("Row " + Integer.toString(xRef) + " and radius " + IJ.d2s(radiusValue,9));
			IJ.log("Match row " + Integer.toString(x) + " in the rt table");
			xRef = averageRadius.length;
		}
	}
	IJ.log(Integer.toString(x) + " / " + Integer.toString(newBranchInfoColumns[0].length));
}

averagedRadiusArray = radiiValues.toArray();
IJ.log(Integer.toString(averageRadius.length));
IJ.log(Integer.toString(averagedRadiusArray.length));
IJ.log(Integer.toString(newBranchInfoColumns[0].length));

//Missing last radius for some reason...

for(i=0; i<averageRadius.length; i++) {
	newBranchInfo.setValue("Averaged Radius", i, averagedRadiusArray[i]);
	newBranchInfo.setValue("Associated skel", i, prevSkel[i]);
	newBranchInfo.setValue("Associated branch", i, prevBranch[i]);
}

newBranchInfo.show("Results");

System.exit();