import ij.IJ; //Import this so that we can use imageJ to open the image
import ij.gui.GenericDialog; //Import so we can create dialog boxes
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.ImagePlus; //Import to allow us to create or alter images
import ij.WindowManager; //Import to allow us to manager windows
import ij.measure; //Import so we can measure things
import ij.measure.Calibration; //Import so we can access and set calibration values
import ij.measure.ResultsTable; //Import so we can access the results table
import ij.plugin.Duplicator; //Import so we can create substacks using the duplicator
import ij.process.ImageProcessor; //Import so we can invert the LUT after thresholding
import ij.plugin.PlugIn; //Import so we can save things without prompting to save changes
import ij.plugin.frame.RoiManager; //Import so we can work with the roi manager
import ij.io.DirectoryChooser; //Import so the user can select a directory from a dialog box

//Import these so we can use analyze skeleton
import sc.fiji.analyzeSkeleton.AnalyzeSkeleton_;
import sc.fiji.analyzeSkeleton.Edge;
import sc.fiji.analyzeSkeleton.Point;

avg = WindowManager.getImage("skeletonisedImage.tif");
dmap = WindowManager.getImage("Dmap.tif");

//avg.hide();
//dmap.hide();

double[] pixelSizeArray = {1.4844, 1.4844, 2.0};
//[0] is xPixelSize, [1] is yPixelSize, [2] is zPixlSize

double[] imageDimensions = {512, 512, 151};
//[0] is width, [1] is height, [2] is slices

//Calculate the volume of the image in calibrated units
avgVolume=1;
for(i=0; i<imageDimensions.length; i++) {
	avgVolume = imageDimensions[i] * pixelSizeArray[i] * avgVolume;
}

double volumeRemoved=100;

//Here we define a class skeletonValues that will contain the radius, skeleton, branch, and coordinate number for each coordinate in our skeleton - we do this so we can sort this data
//by skeleton, then branch, then coordinate number, so that it matches our skeleton coordinate data so we simply have to append our radius to that data rather than search that data
//to find which coords the radius belongs to

//All this sorting code was adapted from http://techthinking.net/2010/04/how-to-sort-two-dimensional-data-based-on-multiple-parameters/
class skeletonValues {

	double xCoord;
	double yCoord;
	double zCoord;
	double xCal;
	double yCal;
	double zCal;
	double skelNo;
	double branchNo;
	double coordNo;
	double radius;

	//Order of the data in skeletonValues is determined by the order of the data we get out of our 3d skeleton coordinates, which is:
	//[0] is x coord, [1] is y, [2] is z, [3] to [5] is calibrated, [6] to [8] is skel, branch and coord, [9] is radius
	
	//Here a skeletonValues object contains the skelValues double array, so each skelValues object has 10 data points, and we define how to get our the radius, skelNo, branchNo, and coordNo from this data
	public skeletonValues(double xCoord, double yCoord, double zCoord, double xCal, double yCal, double zCal, double skelNo, double branchNo, double coordNo, double radius) {
		super();
		this.skelNo = skelNo;
		this.branchNo = branchNo;
		this.coordNo = coordNo;
		this.radius = radius;
	}
}

//This creates a comparator object that returns whether the skeletonvalues at two skeletonValues points (a1 and a2) are different or equal by altering the returned int accordingly
static final Comparator ORDER_BY_SKELNAME = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.skelNo<a2.skelNo) {
			return -1;
		} else if (a1.skelNo>a2.skelNo) {
			return 1;
		} else if (a1.skelNo == a2.skelNo) {
			return 0;
		}
	}
};

//Comparator to compare a1 and a2 on branch number
static final Comparator ORDER_BY_BRANCHNO = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.branchNo<a2.branchNo) {
			return -1;
		} else if (a1.branchNo>a2.branchNo) {
			return 1;
		} else if (a1.branchNo == a2.branchNo) {
			return 0;
		}
	}
};

//Comparator to compare coord numbers between a1 and a2
static final Comparator ORDER_BY_COORD = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.coordNo<a2.coordNo) {
			return -1;
		} else if (a1.coordNo>a2.coordNo) {
			return 1;
		} else if (a1.coordNo == a2.coordNo) {
			return 0;
		}
	}
};

//This creates a final comparator which is a summary of the comparators we've previously defined - essentially, if skelNo matches, we order by branchNo, if that matches we order by Coord, else we stop at whichever
//step the values don't match

//The reason we're using comparators here is so we can use Arrays.sort(T[] a, Comparator<? super T> c) where we can input an array and then use a comparator to sort it - the ORDER_BY_RULES comparator is
//essentially a summary of all the others and so allows us to sort by multiple columns
static final Comparator ORDER_BY_RULES = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		int i = ORDER_BY_SKELNAME.compare(a1, a2);
		if(i == 0){
			i = ORDER_BY_BRANCHNO.compare(a1, a2);
			if(i == 0){
				i = ORDER_BY_COORD.compare(a1, a2);
			}
		}
		return i;
	}
};

//Make sure there are no selections on the skeleton image
IJ.run(avg, "Select None", "");
	
// analyze skeleton
skel = new AnalyzeSkeleton_();
skel.setup("", avg);
skelResult = skel.run(AnalyzeSkeleton_.NONE, false, false, null, true, false);
	
// get graphs (one per skeleton in the image)
graph = skelResult.getGraph();
	
//Create 2D arraylist to store the x, y, and z coordinates of each voxel, as well as their associated skeleton number, branch number, and their calibrated values
ArrayList[][] coordinateValues = new ArrayList[3][3];
//[0][0] is xCoord, [0][1] is yCoord, [0][2] is zCoord
//[1][0] is xCoord calibrated, [1][1] is yCoord calibrated, [1[2] is zCoord caibrated
//[2][0] is skeleton number, [2][1] is branch number, [2][2] is coordinate number

//Fill with arraylists at all indices
for(i0=0; i0<3; i0++) {
	for(i1=0; i1<3; i1++) {
		coordinateValues[i0][i1] = new ArrayList();
	}
}

//This is an array of what we need to multiple our coordinates by to get them calibrated (or not)
double[][] multiplier = {{1,1,1}, {pixelSizeArray[0], pixelSizeArray[1], pixelSizeArray[2]}};

// go through all skeletons
for(i=0 ; i < graph.length; i++ ) {
	listEdges = graph[i].getEdges(); 
	
	// go through all branches - j counts how many branches for each skeleton, our results table won't show data for skeletons without branches or coords
	j=1;
	for( Edge e : listEdges ) {	

		//These are arrays of the coordinates of the first and last pixels in the skeleton branch, with [0] being x, [1] y, and [2] z
		double[] firstCoords = {(double) e.getV1().getPoints().get(0).x, (double) e.getV1().getPoints().get(0).y, (double) e.getV1().getPoints().get(0).z};
		double[] lastCoords = {(double) e.getV2().getPoints().get(0).x, (double) e.getV2().getPoints().get(0).y, (double) e.getV2().getPoints().get(0).z};

		//Looping through 3 times (the 3 1D in allCoords) - to get the coordinates, calibrated coordinates, and skeleton labels
		for(i0=0; i0<3; i0++) {	
			
			//Looping through 3 times (the 3 2D in allCoords) - to get the x, y, and z (or skel, branch, coord) details
			for(i1=0; i1<3; i1++) {
				
				//If we're on our first 2 1D dimensions (coordinates and calibrated coordinates)
				if(i0<2) {
					
					//Set the first values of allCoords[i0][i1] to the first pixel coordinates and multiply by multplier values 
					coordinateValues[i0][i1].add(firstCoords[i1]*multiplier[i0][i1]);
					
					//Loop through all middle pixels, and set allCoords to those middle pixel values 
					for(i2=1; i2<e.getSlabs().size()+1; i2++) {
						
						//Array to store the middle coordinate values
						double[] middleCoords  = {(double) e.getSlabs().get(i2-1).x, (double) e.getSlabs().get(i2-1).y, (double) e.getSlabs().get(i2-1).z};
						coordinateValues[i0][i1].add(middleCoords[i1]*multiplier[i0][i1]);
					}
					
					//Set the last values to the final pixel values
					coordinateValues[i0][i1].add(lastCoords[i1]*multiplier[i0][i1]);
				
				//If we're on our 3rd 1D dimension - skel, branch, and coord numbers
				} else {
					
					//Set coordNo to 0 to start
					coordNo=0;
					
					//Loop through all the pixel values
					for(i2=0; i2<e.getSlabs().size()+2; i2++) {
						
						//Increase coordNo each time
						coordNo++;
						
						//Create an array to store the skeleton, branch, and coordinate number values and then set these in the allCoords array
						double[] skelInfo = {((double) (i+1)), ((double) j),((double) coordNo)};
						coordinateValues[i0][i1].add(skelInfo[i1]);
					}
				}
			}
		}

		//Now we've finished with this branch, increase branch counter j
		j++;
	}
}

//Run analyze skeleton so we can get out the branch length and euclidean distance of all the skeleton branches
IJ.run(avg, "Analyze Skeleton (2D/3D)", "prune=[shortest branch] show");

//Get the results table, close it, then set the branch information table as the results table, and get its object reference
currResults = WindowManager.getWindow("Results");
currResults.dispose();
IJ.renameResults("Branch information", "Results");
ResultsTable branchInfo = ResultsTable.getResultsTable();

//Here we create a double array to store the skeleton number, branch distance, and euclidean distance, from the branch info results table - we also create an int array to store the indices of
//these columns in the table
double [][] branchInfoColumns = new double[4][];
//[0] is skelId, [1] is branch length, [2] is euclidean distance, [3] is for storing the branch number that we calculate 
int[] branchInfoIndices = {0,1,8}; 

//Loop through, getting the 3 columns from the table and storing them in our 2d double array
for(i=0; i<4; i++) {
	if(i<3) {
		branchInfoColumns[i] = branchInfo.getColumnAsDoubles(branchInfoIndices[i]);
	} else {
		branchInfoColumns[i] = new double[branchInfoColumns[0].length];
	}
}

//Create a double value that counts how many branches there are for each skeleton, cast as a double so we can put it into a results table
double currentNo = 1;

//Loop through all the skeleton values, if we're at the first one, we set the branch number as 1, else we check how the current skeleton compares to the previous one, and if they're teh same,
//we increase our branch number, otherwise we reset to 1, and store it in our branchInfoColumns [3] array
for(skelIndex=0; skelIndex<branchInfoColumns[0].length; skelIndex++) {
	if(skelIndex==0) {
		branchInfoColumns[3][skelIndex] = currentNo;
	} else {
		if(branchInfoColumns[0][skelIndex] == branchInfoColumns[0][skelIndex-1]) {
			currentNo = currentNo+1;
		} else {
			currentNo = 1;
		}
		branchInfoColumns[3][skelIndex] = currentNo;
	}
}

//Get the imagestack of our dmap image
dmapStack = dmap.getImageStack();

//Create an arraylist to store pixel intensity values
ArrayList pixelValues = new ArrayList();

//Loop through all skeleton points
for(i=0; i<coordinateValues[0][0].size(); i++) {
	
	//Get out the pixel value of each skeleton point in the stack and store it in our arraylist
	pixelValues.add(dmapStack.getVoxel((int) coordinateValues[0][0].get(i), (int) coordinateValues[0][1].get(i), (int) coordinateValues[0][2].get(i)));
}

//Here we create a skeletonValues array to store the data from our radius measurements - this is so that we can sort the skeletonValues
//array using skeleton, branch, and coordinate number in ascending order, so that we simply have to transpose our radii
//onto our 3D coords data, rather than having to match the coordinates between arrays
skeletonValues[] radiiTable = new skeletonValues[coordinateValues[0][0].size()];

//Create a new double array to store our coordinate and radius data in the properly formatted manner
double[] skeletonValuesToUse = new double[10];

//Loop through all skeleton points
for(thirdD = 0; thirdD < coordinateValues[0][0].size(); thirdD++) {
	
	//Set the index to fill to 0 to begin
	indexToUse = 0;
	
	//Loop through all data in our coordinateValues array and fill each index of the skeletonValuesToUse array with the data - i.e.
	//xcoord, y coord, z coord, xcal, y cal, zcal, skelNo, branchNo, coordNo, increasing index each time
	for(column = 0; column<3; column++) {
		for(row=0; row<3; row++) {
			skeletonValuesToUse[indexToUse] = coordinateValues[column][row].get(thirdD);
			indexToUse++;
			}
		}

	//Once filled with skeleton data, we then add the radius value for that coordinate and fill an index of our radiitable with the values we stored in our skeletonValuestoUse array
	//and we reset indexToUse to 0	
	skeletonValuesToUse[indexToUse] = pixelValues.get(thirdD);
	radiiTable[thirdD] = new skeletonValues(skeletonValuesToUse[0], skeletonValuesToUse[1], skeletonValuesToUse[2], skeletonValuesToUse[3], skeletonValuesToUse[4], skeletonValuesToUse[5], skeletonValuesToUse[6], skeletonValuesToUse[7], skeletonValuesToUse[8], skeletonValuesToUse[9]);
	indexToUse=0;
}

//Here we sort our radiiTable first by skeletonNo, then by branchNo, then by coordinateNo
Arrays.sort(radiiTable, ORDER_BY_RULES);

//Here we create a double array to store our now sorted radii, before we fill it with the radii values from our sorted radiiTable
double[] sortedRadii = new double[pixelValues.size()];
for(i=0; i<sortedRadii.length; i++) {
	sortedRadii[i] = ((double) radiiTable[i].radius);
}	

//This variable is to store the runningTotal of coordinate radii so that we can then divide it by the appropriate number
//of coordinate to get the average radius for a particular branch
double runningTotal=0;

//Create an arraylist to store the average radius for each branch and the number of coordinates
ArrayList[] radiiandCoords = new ArrayList[2];
for(i=0; i<radiiandCoords.length; i++) {
	radiiandCoords[i] = new ArrayList();
}

//Create double arrays to store the previous coordinate values, and the current coordinate values so we can compare them
double[] prevValues = new double[4];
double[] currentValues = new double[3];
//[0] is skel, [1] is branch, [3] is number of coords, [4] is radii

//Declare the current and previous indices - reason we have to do this is so that when we're on our final index, we can use different indices
int currentIndex;
int prevIndex;

//Also declare a writeRadius boolean, which when true causes the code to output the average radius of a unique skeleton/branch combo
boolean writeRadius = false;

//Here we loop through the length of all our coordinates +1 time since we're comparing two rows to each other, so we need
//an extra iteration to get the right number of radii
for(i=0; i<sortedRadii.length+1; i++) {

	//If we're not on our first or last index, we get the index of our current values and previous values
	if(i>0 && i<sortedRadii.length) {
		currentIndex = (int) i;
		prevIndex = (int) i-1;
	
	//If we're on our last index, we get the last and second last values, and set writeRadius to true (otherwise we end up with one fewer datapoints if the
	//last index is the same as the second last)
	} else if (i==sortedRadii.length) {
		currentIndex = (int) i-1;
		prevIndex = (int) i-2;
		writeRadius = true;
	}

	if(i>0) {
	
		//Looping through 4 times so we can calculate the previous and current skel, branch, coordNo, and radius
		for(i0=0; i0<4; i0++) {	
			
			//if we're in the first two loops, we get our skel, branch, and coordNo from the coordinateValues array - getting values for our current
			//index and the index prior
			if(i0<3) {
				prevValues[i0] = coordinateValues[2][i0].get(prevIndex);
				currentValues[i0] = coordinateValues[2][i0].get(currentIndex);	
			
			//If on the third loop we get our radius from our sorted radii array
			} else {
				prevValues[i0] = sortedRadii[prevIndex];
			}
		}
	
		//Increase the running total of radii using the previous radius and the previous running total
		runningTotal = runningTotal + prevValues[3];
	}

	//If the previous values dont match the current values (i.e. we're not on an index for a different branch/skel combo, set writeRadius to true
	if(prevValues[0] != currentValues[0] || prevValues[1] != currentValues[1]) {
		writeRadius = true;
	}

	//If our previous skel or previous branch doesnt match our current one, or we're on our last index
	if (writeRadius == true) {
		
		//IJ.log(IJ.d2s(prevValues[0], 9) + " " + IJ.d2s(prevValues[1],9));
		
		//We calculate the number of coordinates with that associated unique skel + branch combo the work out the average radii based on that
		//and store it in our averageRadii arrayList
		noCoords = prevValues[2];

		//Fill our arrayList array with the values we want to store - average radius and the number of coordinates
		radiiandCoords[0].add(runningTotal/noCoords);
		radiiandCoords[1].add(noCoords);

		//Now that we're done with our current skel/branch combo, we reset running total to 0						
		runningTotal = 0;

		//Set writeradius to false again
		writeRadius = false;
	}
}

//Create a new results table to output the 3D skeleton information
rt = new ResultsTable();

//Create a 2D string array of headers we'll use on our results table
String[][] resultsHeaders = {{"X Coordinate", "Y Coordinate", "Z Coordinate"}, {"Calibrated X", "Calibrated Y", "Calibrated Z"}, {"Skeleton Number", "Branch Number", "Coordinate Number"}};

//Go through all the table columns and rows, and fill our results table with the appropriate header and values
for(columnAdding = 0; columnAdding<3; columnAdding++) {
	for(rowAdding=0; rowAdding<3; rowAdding++) {
		for(thirdD = 0; thirdD<coordinateValues[columnAdding][rowAdding].size(); thirdD++) {
			rt.setValue(resultsHeaders[columnAdding][rowAdding], thirdD, (double) coordinateValues[columnAdding][rowAdding].get(thirdD));
			
			//If we're adding our last data to the table, we can now add our radii data as well
			if(columnAdding==2 && rowAdding ==2) {
				rt.setValue("Radius", thirdD, sortedRadii[thirdD]);
			}
		}
	}
}

rt.show("3D Coordinates");

//Create a new results table to show all the branch info
finalTable = new ResultsTable();

String[] finalTableHeaders = {"Skeleton Number", "Branch Number", "Number of Coordinates", "Radius", "Branch Length", "Euclidean Distance"};
int[] indicesForFinalTable = {0,3,1,0,1,2};

//Loop through all the branch summary info, setting the skeleton, branch, distance, and euclidean distance from the original
//analyze skeleton results table, and setting the number of coordinates and radii from the calculated values
for(i=0; i<branchInfoColumns[0].length; i++) {
	for(i0=0; i0<finalTableHeaders.length; i0++) {
		if(i0==2 || i0 ==3) {
			finalTable.setValue(finalTableHeaders[i0], i, radiiandCoords[indicesForFinalTable[i0]].get(i));
		} else {
			finalTable.setValue(finalTableHeaders[i0], i, branchInfoColumns[indicesForFinalTable[i0]][i]);
		}
	}
}

//Display the final table as the branch information table
finalTable.show("Branch Details");

//Putting this bit any earlier seems to mess with analyze skeleton..so be careful with it
if( WindowManager.getWindow("Tagged skeleton") != null) {
	WindowManager.getWindow("Tagged skeleton").dispose();
}