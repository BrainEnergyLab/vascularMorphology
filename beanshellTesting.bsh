import ij.IJ; //Import this so that we can use imageJ to open the image
import ij.gui.GenericDialog; //Import so we can create dialog boxes
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.ImagePlus; //Import to allow us to create or alter images
import ij.WindowManager; //Import to allow us to manager windows
import ij.measure; //Import so we can measure things
import ij.macro.Variable; //Import so we can use the variable type
import ij.measure.Calibration; //Import so we can access and set calibration values
import ij.measure.ResultsTable; //Import so we can access the results table
import ij.plugin.Duplicator; //Import so we can create substacks using the duplicator
import ij.process.ImageProcessor; //Import so we can invert the LUT after thresholding
import ij.plugin.PlugIn; //Import so we can save things without prompting to save changes
import ij.plugin.frame.RoiManager; //Import so we can work with the roi manager
import ij.io.DirectoryChooser; //Import so the user can select a directory from a dialog box
import ij.gui.PointRoi; //import so we can make point ROIs
import ij.plugin.filter.Analyzer; //import so we can use the analyzer object

//Import these so we can use analyze skeleton
import sc.fiji.analyzeSkeleton.AnalyzeSkeleton_;
import sc.fiji.analyzeSkeleton.Edge;
import sc.fiji.analyzeSkeleton.Point;


avg = WindowManager.getImage("skeletonisedImage.tif");
dmap = WindowManager.getImage("Dmap.tif");

double[] pixelSizeArray = {1.4844, 1.4844, 2.0};
//[0] is xPixelSize, [1] is yPixelSize, [2] is zPixlSize

double[] imageDimensions = {512, 512, 151};
//[0] is width, [1] is height, [2] is slices

//Calculate the volume of the image in calibrated units
avgVolume=1;
for(i=0; i<imageDimensions.length; i++) {
	avgVolume = imageDimensions[i] * pixelSizeArray[i] * avgVolume;
}

double volumeRemoved=100;

//Here we define a class skeletonValues that will contain the radius, skeleton, branch, and coordinate number for each coordinate in our skeleton - we do this so we can sort this data
//by skeleton, then branch, then coordinate number, so that it matches our skeleton coordinate data so we simply have to append our radius to that data rather than search that data
//to find which coords the radius belongs to

//All this sorting code was adapted from http://techthinking.net/2010/04/how-to-sort-two-dimensional-data-based-on-multiple-parameters/
class skeletonValues {

	double radius;
	double xCal;
	double yCal;
	double zCal;
	double xCoord;
	double yCoord;
	double zCoord;
	double skelNo;
	double branchNo;
	double coordNo;

	//[0] is x coord, [1] is y, [2] is z, [3] to [5] is calibrated, [6] to [8] is skel, branch and coord, [9] is radius
	
	//Here a skeletonValues object contains the skelValues double array, so each skelValues object has 10 data points, and we define how to get our the radius, skelNo, branchNo, and coordNo from this data
	public skeletonValues(double xCoord, double yCoord, double zCoord, double xCal, double yCal, double zCal,  double skelNo, double branchNo, double coordNo, double radius) {
		super();
		this.radius = radius;
		this.skelNo = skelNo;
		this.branchNo = branchNo;
		this.coordNo = coordNo;
	}
}

//This creates a comparator object that returns whether the skeletonvalues at two skeletonValues points (a1 and a2) are different or equal by altering the returned int accordingly
static final Comparator ORDER_BY_SKELNAME = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.skelNo<a2.skelNo) {
			return -1;
		} else if (a1.skelNo>a2.skelNo) {
			return 1;
		} else if (a1.skelNo == a2.skelNo) {
			return 0;
		}
	}
};

//Comparator to compare a1 and a2 on branch number
static final Comparator ORDER_BY_BRANCHNO = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.branchNo<a2.branchNo) {
			return -1;
		} else if (a1.branchNo>a2.branchNo) {
			return 1;
		} else if (a1.branchNo == a2.branchNo) {
			return 0;
		}
	}
};

//Comparator to compare coord numbers between a1 and a2
static final Comparator ORDER_BY_COORD = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.coordNo<a2.coordNo) {
			return -1;
		} else if (a1.coordNo>a2.coordNo) {
			return 1;
		} else if (a1.coordNo == a2.coordNo) {
			return 0;
		}
	}
};

//This creates a final comparator which is a summary of the comparators we've previously defined - essentially, if skelNo matches, we order by branchNo, if that matches we order by Coord, else we stop at whichever
//step the values don't match

//The reason we're using comparators here is so we can use Arrays.sort(T[] a, Comparator<? super T> c) where we can input an array and then use a comparator to sort it - the ORDER_BY_RULES comparator is
//essentially a summary of all the others and so allows us to sort by multiple columns
static final Comparator ORDER_BY_RULES = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		int i = ORDER_BY_SKELNAME.compare(a1,a2);
		if(i == 0){
			i = ORDER_BY_BRANCHNO.compare(a1,a2);
			if(i == 0){
				i = ORDER_BY_COORD.compare(a1,a2);
			}
		}
		return i;
	}
};

//Make sure there are no selections on the skeleton image
IJ.run(avg, "Select None", "");
	
// analyze skeleton
skel = new AnalyzeSkeleton_();
skel.setup("", avg);
skelResult = skel.run(AnalyzeSkeleton_.NONE, false, false, null, true, false);
	
// get graphs (one per skeleton in the image)
graph = skelResult.getGraph();
	
//Create 2D arraylist to store the x, y, and z coordinates of each voxel, as well as their associated skeleton number, branch number, and coord number and their calibrated values

ArrayList[][] table = new ArrayList[3][3];
//[0][0] is xCoords, [0][1] is yCoords, [0][2] is zCoords
//[1][0] is xCoordsCal, [1][1] is yCoordsCal, [1][2] is zCoordsCal
//[2][0] is skeletonNo, [2][1] is branchNo, [2][2] is coordNo

//Fill table with arrayLists
for(i=0; i<3; i++) {
	for(j=0; j<3; j++) {
		table[i][j] = new ArrayList();
	}
}

	
// go through all skeletons
for(i=0 ; i < graph.length; i++ ) {
	listEdges = graph[i].getEdges(); 
	
	// go through all branches - j counts how many branches for each skeleton, our results table won't show data for skeletons without branches or coords
	j=1;
	for( Edge e : listEdges ) {	
		
		//Get the coords of the starting point
		p1 = e.getV1().getPoints().get( 0 );
		
		//no points is how many coordinates we've collected in this branch
		noPoints = 1;

		//Create a double array to store the x, y, and z coordinates of the p1 point and one to store the skeleton number, branch number, and coordinate number (all starting from 1)
		double[] pixelCoords = {p1.x, p1.y, p1.z};
		double[] skelInfo = {((double) (i+1)), ((double) j),((double) noPoints)};
		
		//Loop through the columns and rows of the 2d arraylist table - if in the first column, we're adding the raw coordinates, if the second, we're adding the calibrated coordinates,
		//and if the third, we're adding the skeleton, branch, and coordinate info
		for(columnAdding = 0; columnAdding<3; columnAdding++) {
			for(rowAdding=0; rowAdding<3; rowAdding++) {
				if(columnAdding==0) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]);
				} else if (columnAdding==1) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]*pixelSizeArray[rowAdding]);
				} else if (columnAdding ==2) {
					table[columnAdding][rowAdding].add(skelInfo[rowAdding]);
				}
			}
		}

		//Increase our count of coordinates
		noPoints++;	
		
		//Get coords for all points between starting and end coords
		for( Point p : e.getSlabs() ) {		  			
			
			//Same story here with the arrays and loop to add the arrays
			double[] pixelCoords = {p.x, p.y, p.z};
			double[] skelInfo = {((double) (i+1)), ((double) j),((double) noPoints)};
			for(columnAdding = 0; columnAdding<3; columnAdding++) {
				for(rowAdding=0; rowAdding<3; rowAdding++) {
					if(columnAdding==0) {
						table[columnAdding][rowAdding].add(pixelCoords[rowAdding]);
					} else if (columnAdding==1) {
						table[columnAdding][rowAdding].add(pixelCoords[rowAdding]*pixelSizeArray[rowAdding]);
					} else if (columnAdding ==2) {
						table[columnAdding][rowAdding].add(skelInfo[rowAdding]);
					}
				}
			}
			noPoints++;	
		}	
		
		//Get final coord points
		p2 = e.getV2().getPoints().get( 0 );

		//Same story here
		double[] pixelCoords = {p2.x, p2.y, p2.z};
		double[] skelInfo = {((double) (i+1)), ((double) j),((double) noPoints)};
		for(columnAdding = 0; columnAdding<3; columnAdding++) {
			for(rowAdding=0; rowAdding<3; rowAdding++) {
				if(columnAdding==0) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]);
				} else if (columnAdding==1) {
					table[columnAdding][rowAdding].add(pixelCoords[rowAdding]*pixelSizeArray[rowAdding]);
				} else if (columnAdding ==2) {
					table[columnAdding][rowAdding].add(skelInfo[rowAdding]);
				}
			}
		}
		
		//As this is the final point in the branch, we increase branch number
		j++;
	}
}

//Create a 3D double array to store the data in the table arrayList (convert from arrayList to double array)
double[][][] valueStore = new double[3][3][];
//[0][0] is xCoords, [0][1] is yCoords, [0][2] is zCoords
//[1][0] is xCoordsCal, [1][1] is yCoordsCal, [1][2] is zCoordsCal
//[2][0] is skeletonNo, [2][1] is branchNo, [2][2] is coordNo

//Create a 2D string array to store the labels for our values in our valueStore array
String[][] tableHeaders = {{"xCoords", "yCoords", "zCoords"}, {"xCoordsCal", "yCoordsCal", "zCoordsCal"}, {"Skeleton Number", "Branch Number", "Coordinate Number"}};

//Loop through the columns and rows, creating the right sized arrays in the third dimension according to the sizes in the arraylist table
for(j = 0; j<3; j++) {
	for(k =0; k<3; k++) {
		valueStore[j][k] =  new double[table[j][k].size()];
	}
}	

//Create a new results table to store the 3d coordinate data
rt = new ResultsTable();	

//Go through all the table columns and rows, and fill the correct index in our valueStore array with the table value, making sure we cast it as a double - also fill our results table with the data
for(columnAdding = 0; columnAdding<3; columnAdding++) {
	for(rowAdding=0; rowAdding<3; rowAdding++) {
		for(thirdD = 0; thirdD<table[columnAdding][rowAdding].size(); thirdD++) {
			valueStore[columnAdding][rowAdding][thirdD] = (double) table[columnAdding][rowAdding].get(thirdD);
			rt.setValue(tableHeaders[columnAdding][rowAdding], thirdD, valueStore[columnAdding][rowAdding][thirdD]);
		}
	}
}

rt.show("3D Coordinates");

//Run analyze skeleton so we can get out the branch length and euclidean distance of all the skeleton branches
IJ.run(avg, "Analyze Skeleton (2D/3D)", "prune=[shortest branch] show");

//Get the results table, close it, then set the branch information table as the results table, and get its object reference
currResults = WindowManager.getWindow("Results");
currResults.dispose();
IJ.renameResults("Branch information", "Results");
ResultsTable branchInfo = ResultsTable.getResultsTable();


//Here we create a double array to store the skeleton number, branch distance, and euclidean distance, from the branch info results table - we also create an int array to store the indices of
//these columns in the table
double [][] branchInfoColumns = new double[4][];
int[] branchInfoIndices = {0,1,8}; 
//[0] is skelId, [1] is branch length, [2] is euclidean distance, [3] is for storing the branch number that we calculate 

//Loop through, getting the 3 columns from the table and storing them in our 2d double array
for(i=0; i<4; i++) {
	if(i<3) {
	branchInfoColumns[i] = branchInfo.getColumnAsDoubles(branchInfoIndices[i]);
	} else {
		branchInfoColumns[i] = new double[branchInfoColumns[0].length];
	}
}

//Create a double value that counts how many branches there are for each skeleton, cast as a double so we can put it into a results table, and 
double currentNo = 1;

//Maybe store our branch number values in a new array, rather than setting it in a results tables

//Loop through all the skeleton values, if we're at the first one, we set the branch number as 1, else we check how the current skeleton compares to the previous one, and if they're teh same,
//we increase our branch number, otherwise we reset to 1, and store it in our branchInfoColumns [3] array
for(skelIndex=0; skelIndex<branchInfoColumns[0].length; skelIndex++) {
	if(skelIndex==0) {
		branchInfoColumns[3][skelIndex] = currentNo;
	} else {
		if(branchInfoColumns[0][skelIndex] == branchInfoColumns[0][skelIndex-1]) {
			currentNo = currentNo+1;
		} else {
			currentNo = 1;
		}
		branchInfoColumns[3][skelIndex] = currentNo;
	}
}

//Set the measurements we're making to calculate the mean
IJ.run("Set Measurements...", "mean redirect=None decimal=9");

//Get the number of slices in the image
imageSlices = dmap.getNSlices();

//Create an arraylist array to store the coords and skel,branch,and coord numbers and their associated radius
ArrayList[] newTable = new ArrayList[10];
//[0] is x coord, [1] is y, [2] is z, [3] to [5] is calibrated, [6] to [8] is skel, branch and coord, [9] is radius

for(i=0; i<newTable.length; i++) {
	newTable[i] = new ArrayList();
}

//Loop through all the slices in our distance map, setting the image to that slice each time
for(i=1; i<imageSlices+1; i++) {		
	dmap.setSlice(i);

	ArrayList[] xandyLists = new ArrayList[2];

	for(i0=0; i0<xandyLists.length; i0++) {
		xandyLists[i0] = new ArrayList();
	}

	//Loop through the arrays storing the coordinates of our skeleton
	for(i0=0; i0<valueStore[0][0].length; i0++) {
		
		//If the z coordinate of the row of our 3d coords data matches the slice we're on
		int zIntCurr = (int) valueStore[0][2][i0] + 1;
		if(zIntCurr == i) {				
			
			//Then we loop through the valueStore array and get out the x,y,z,skelNo,branchNo,and coordNo of that point and store it in newTable
			for(k=0; k<3; k++) {
				for(j=0; j<3; j++) {
					//IJ.log(Integer.toString(k) + " " + Integer.toString(j) + " " + Integer.toString(i0) + " " + IJ.d2s(valueStore[0][0][0]));
					//IJ.log(newTable[0].size());
					newTable[(j+(k*3))].add(valueStore[k][j][i0]);
				}
				if(k<2) {
					//Here we get out the x and y points and put them in the x and y arraylist array
					xandyLists[k].add(valueStore[0][k][i0]);
				}
			}	
		}
	}

	//Here we convert our x and y arraylist array to 2d int array
	int[][] xandyArrays = new int[2][];
	for(i0=0; i0<2; i0++) {
		xandyArrays[i0] = new int[xandyLists[i0].size()];
		for(i1 = 0; i1<xandyLists[0].size(); i1++) {
			xandyArrays[i0][i1] = (int) xandyLists[i0].get(i1);
		}
	}	

	//Then we create a point array using the xandyarrays, make sure there is no selection on the dmap image, set this point selection,
	pointRoi = new PointRoi(xandyArrays[0], xandyArrays[1], xandyArrays[0].length);	
	IJ.run(dmap, "Select None", "");
	dmap.setRoi(pointRoi);

	//We now create a resultstable to store our measurements, and an analyzer object that reference this table and our
	//distance map image
	meanResults = new ResultsTable();
	meanMeasure = new Analyzer(dmap, meanResults);

	//Here we measure using the analyzer, then get out the mean results column from the results table, add this in its entirety to the newTable[9]
	//arrayList, then make sure there are no more selections on dmap
	meanMeasure.measure();
	double[] radiusMeasurements = meanResults.getColumnAsDoubles(1);
	for(i0=0; i0<meanResults.size(); i0++) {
		newTable[9].add(radiusMeasurements[i0]);
	}
	IJ.run(dmap, "Select None", "");
	
}

//Here we create a skeletonValues array to store the data from our radius measurements - this is so that we can sort the skeletonValues
//array using skeleton, branch, and coordinate number in ascending order, so that we simply have to transpose our radii
//onto our 3D coords data, rather than having to match the coordinates between arrays
skeletonValues[] radiiTable = new skeletonValues[newTable[0].size()];

//Here we fill our skeletonValuesToUse array with all the data in a single row (i.e. coordinates, calibrated coordinates, skel values, and radius)
//before then assigning it to our radiiTable array
for(i=0; i<newTable[0].size(); i++) {
	//Here we create a double array to store each row of data that we want to then put into our skeletonValues array
	double[] skeletonValuesToUse = new double[10];
	for(i0=0; i0<10; i0++) {
		skeletonValuesToUse[i0] = newTable[i0].get(i);
	}
	radiiTable[i] = new skeletonValues(skeletonValuesToUse[0], skeletonValuesToUse[1], skeletonValuesToUse[2], skeletonValuesToUse[3], skeletonValuesToUse[4],
									   skeletonValuesToUse[5], skeletonValuesToUse[6], skeletonValuesToUse[7], skeletonValuesToUse[8], skeletonValuesToUse[9]);

}

//Here we sort our radiiTable first by skeletonNo, then by branchNo, then by coordinateNo
Arrays.sort(radiiTable, ORDER_BY_RULES);

//Here we create a double array to store our now sorted radii, before we fill it with the radii values from our sorted radiiTable
double[] sortedRadii = new double[newTable[9].size()];
for(i=0; i<sortedRadii.length; i++) {
	sortedRadii[i] = ((double) radiiTable[i].radius);
}

//This variable is to store the runningTotal of coordinate radii so that we can then divide it by the appropriate number
//of coordinate to get the average radius for a particular branch
double runningTotal=0;

//Create an arraylist to store the average radius for each branch and the number of coordinates, as well as a double array to store the values
//to put into the arraylist
ArrayList[] radiiandCoords = new ArrayList[2];
for(i=0; i<radiiandCoords.length; i++) {
	radiiandCoords[i] = new ArrayList();
}
double[] radiiandCoordsValues = new double[2];

//Create double arrays to store the previous coordinate values, and the current coordinate values so we can compare them
double[] prevValues = new double[3];
double[] currentValues = new double[3];
//[0] is skel, [1] is branch, [2] is radii

//Here we loop through the length of all our coordinates +1 time since we're comparing two rows to each other, so we need
//an extra iteration to get the right number of radii
for(i=0; i<sortedRadii.length+1; i++) {
	
	//Looping through 3 times so we can calculate the previous and current coordinates skel, branch, and radius
	for(i0=0; i0<3; i0++) {
		
		//If we're not on the first or last inidices
		if(i>0 && i<sortedRadii.length) {
			if(i0<2) {
				prevValues[i0] = valueStore[2][i0][i-1];
				currentValues[i0] = valueStore[2][i0][i];
			} else {
				prevValues[i0] = sortedRadii[i-1];
				//IJ.log(Integer.toString(i));
				currentValues[i0] = sortedRadii[i];
			}
		} else if (i==sortedRadii.length) {
			if(i0<2) {
				prevValues[i0] = valueStore[2][i0][i-2];
				currentValues[i0] = valueStore[2][i0][i-1];
				IJ.log(IJ.d2s(prevValues[i0],9) + " " + IJ.d2s(currentValues[i0], 9));
			} else {
				prevValues[i0] = sortedRadii[i-2];
				currentValues[i0] = sortedRadii[i-1];
			}
		}
	}

	//Increase the running total of radii using the previous radius and the previous running total
	runningTotal = runningTotal + prevValues[2];

	//If our previous skel or previous branch doesnt match our current one
	if (prevValues[0] != currentValues[0] || prevValues[1] != currentValues[1]) {

		//We calculate the number of coordinates with that associated unique skel + branch combo the work out the average radii based on that
		//and store it in our averageRadii arrayList
		noCoords = valueStore[2][2][i-1];

		//Fill our double array with the values we want to store - average radius and the number of coordinates, then add these
		//to our arraylist array
		//IJ.log(IJ.d2s(prevValues[0],9) + " " + IJ.d2s(prevValues[1],9));
		//IJ.log(IJ.d2s(runningTotal,9) + " " + IJ.d2s(runningTotal/noCoords,9) + " " + IJ.d2s(noCoords,9));
		
		radiiandCoordsValues[0] = (double) runningTotal/noCoords;
		radiiandCoordsValues[1] = (double) noCoords;
		
		for(i0=0; i0<2; i0++) {
			//IJ.log(IJ.d2s(radiiandCoordsValues[i0], 9));
			radiiandCoords[i0].add(radiiandCoordsValues[i0]);
		}

		//Now that we're done with our current skel/branch combo, we reset running total to 0						
		runningTotal = 0;
	} else {
		if(i==sortedRadii.length) {
			//We calculate the number of coordinates with that associated unique skel + branch combo the work out the average radii based on that
			//and store it in our averageRadii arrayList
			noCoords = valueStore[2][2][i-1];
			IJ.log(IJ.d2s(noCoords,9));
	
			//Fill our double array with the values we want to store - average radius and the number of coordinates, then add these
			//to our arraylist array
			//IJ.log(IJ.d2s(prevValues[0],9) + " " + IJ.d2s(prevValues[1],9));
			//IJ.log(IJ.d2s(runningTotal,9) + " " + IJ.d2s(runningTotal/noCoords,9) + " " + IJ.d2s(noCoords,9));
			
			radiiandCoordsValues[0] = (double) runningTotal/noCoords;
			radiiandCoordsValues[1] = (double) noCoords;
			
			for(i0=0; i0<2; i0++) {
				//IJ.log(IJ.d2s(radiiandCoordsValues[i0], 9));
				radiiandCoords[i0].add(radiiandCoordsValues[i0]);
			}	
					
		}
	}
}

IJ.log(Integer.toString(branchInfoColumns[0].length) + " " + Integer.toString(radiiandCoords[0].size()));

finalTable = new ResultsTable();
for(i=0; i<branchInfoColumns[0].length; i++) {
	finalTable.setValue("Skeleton Number", i, branchInfoColumns[0][i]);
	finalTable.setValue("Branch Number", i, branchInfoColumns[3][i]);
	finalTable.setValue("Number of Coordinates", i, radiiandCoords[1].get(i));
	finalTable.setValue("Radius", i, radiiandCoords[0].get(i));
	finalTable.setValue("Branch Length", i, branchInfoColumns[1][i]);
	finalTable.setValue("Euclidean Distance", i, branchInfoColumns[2][i]); 
}

finalTable.show("Branch Details");