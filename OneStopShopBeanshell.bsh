import ij.IJ; //Import this so that we can use imageJ to open the image
import ij.gui.GenericDialog; //Import so we can create dialog boxes
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.ImagePlus; //Import to allow us to create or alter images
import ij.WindowManager; //Import to allow us to manager windows
import ij.measure; //Import so we can measure things
import ij.measure.Calibration; //Import so we can access and set calibration values
import ij.measure.ResultsTable; //Import so we can access the results table
import ij.plugin.Duplicator; //Import so we can create substacks using the duplicator
import ij.process.ImageProcessor; //Import so we can invert the LUT after thresholding
import ij.plugin.PlugIn; //Import so we can save things without prompting to save changes
import ij.plugin.frame.RoiManager; //Import so we can work with the roi manager

/////////////////////////
import ij.plugin.filter.Analyzer;  //Not sure what this does...try running without
////////////////////////

//This is basically declaring a function
//Argsin are the directory to search, the substring to search for, and an arraylist declared outside the function to fill with matching locations
public static listFilesAndFilesSubDirectories(String directoryName, String substring, ArrayList fileLocations) {

	//Here we declare our folder as a file variable for our directory and create a file array of the files within folder
	File folder = new File(directoryName);
	File [] listOfFiles = folder.listFiles();
	
	//Loop through the files in the file list
	for (File file:listOfFiles) {
		//If the file we're checking is a file and not a directory
		if (file.isFile()) {
			//And if it contains the substring we're interested in within its full path
			if(file.getAbsolutePath().contains(substring)) {
				//We store the full path in the output ArrayList;
				String stringForm = file.getAbsolutePath();
				File fileForm = new File(stringForm);
				fileLocations.add(fileForm);
			
			}
		//If the file we're checking is a directory, then we run the whole thing on that directory
		} else if (file.isDirectory()) {
			listFilesAndFilesSubDirectories(file.getAbsolutePath(), substring, fileLocations);           
		}
	}

	//Here we convert out ArrayList to a string array and return it
	File[] arrayForm = fileLocations.toArray(new File[0]);
	return arrayForm;
}

//This asks the user if they wish to remove ROIs from the image, and outputs the area of ROI removed and over what range of slices
//Argsin are just the title of the image to be ROI edited
public static roiRemoval(String imageTitle, Checkbox removeROIs, int timesRun) {

	//Not necessary anymore

/////////////////////////////////
	
	//Here we create a 2D arraylist to dynamically store out roiNames, 2D area, and slice area	
	//ArrayList[][] table = new ArrayList[1][3];
	//table[0][0] = new ArrayList(); // add another ArrayList object to [0,0] this is for roiNames
	//table[0][1] = new ArrayList(); // add another ArrayList object to [0,1] this is for twoDArea
	//table[0][2] = new ArrayList(); // add another ArrayList object to [0,2] this is for sliceArea

/////////////////////////////////

	//Create an arraylist to store the beginning and ending slices set by the user for each roi
	ArrayList slicesToRemove = new ArrayList();

	//Create variable to count how many ROIs we clear
	int count = 0;

	//Set the image we're working with to a variable
	image = WindowManager.getImage(imageTitle);
	image.show();

	//Get the dimensions of the image, and create a new blank image in the same dimensions that will store the masks of the rois created
	int[] imageDimensions = image.getDimensions();
	maskImage = IJ.createImage("Mask", "8-bit black", imageDimensions[0], imageDimensions[1], imageDimensions[3]);
	//[0] = width; [1] = height; [3] = slices

	//Show the maskImage
	maskImage.show();

	//Find out what unit the input image is calibrated in
	calibratedUnit = image.getCalibration().getXUnit();

	//If the image isn't calibrated in um, prompt the user to calibrate it in um until it is
	while(calibratedUnit!="Âµm") {	
		new WaitForUserDialog("Calibration", "Calibrate the image into um in the next window").show();
		IJ.run(image, "Properties...", "");
		calibratedUnit = image.getCalibration().getXUnit();
		}

	//Open the ROI manager and create a variable to refer to the open instance
	IJ.run("ROI Manager...", "");
	RoiManager rm = RoiManager.getInstance();

	oldRemoveROIsValue=removeROIs;
		
	//If the checkbox was true (to create ROIs), then enter the loop for removing bits of the image
	while (removeROIs.getState() == true) {
			
		//Show the avg image then ask the user for input
		image.show();
		maskImage.hide();	
		new WaitForUserDialog("ROI selection", "Draw a ROI to exclude from image if desired, and set the stack to the slice you want to start at").show();
			
		//Get the number of the slice set
		int startSlice = image.getSlice();

		//Get the slice chosen by the user as the end and calculate difference
		new WaitForUserDialog("ROI selection", "Set the slice where you want the ROI to end").show();
		int endSlice = image.getSlice();

		//If the endslice is set before the start then we go back to the start of the loop and show an error message
		if(endSlice<=startSlice) {
				
			new WaitForUserDialog("Slice error", "End slice was set before the start slice").show();
			
			} else {

			//Once the roi is drawn we add it to our roi manager
			rm.addRoi(image.getRoi());

			//We also add our start and end slices to our slicesToRemove arrayList
			slicesToRemove.add(startSlice);
			slicesToRemove.add(endSlice);

			maskImage.show();
				
			//Loop through the slices from start to end, each time clearing the area within the ROI in our input and mask images image
			for (int clearSlice = startSlice; clearSlice <= endSlice; clearSlice++) {
				image.setSlice(clearSlice);
				IJ.run(image, "Clear", "slice");
				RoiManager rm = RoiManager.getInstance();
				IJ.run(maskImage, "Select None", "");
				IJ.selectWindow("Mask");
				rm.select(count);
				maskImage.setSlice(clearSlice);
				IJ.run(maskImage, "Fill", "slice");		
			}

			maskImage.hide();

			//Not necessary anymore

/////////////////////////////////

			//Add our count, area, and depth to our dyanmic arrays
			//table[0][0].add(count);
			//table[0][1].add(twoDArea);
			//table[0][2].add(sliceArea);
		
			//IJ.log("2D Area: " + IJ.d2s(twoDArea, 9) + " Slice Area: " + Integer.toString(sliceArea) + " Pixel Width: " + IJ.d2s(pxlWidth, 9) + " Pixel Depth: " + IJ.d2s(pxlDepth, 9) + " Unit: " + unit);

/////////////////////////////////			
			
			//Create a dialog to ask the user whether they want to manually remove any more ROIs - if yes we repeat the loop
			NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Cleaning image");
			userInputs.addCheckbox("Do you want to manually remove another ROI from the image?", false);
			userInputs.showDialog();
	
			//Get the checkbox (which returns a vector so we have to get an index of it)
			roiChoice = userInputs.getCheckboxes();
			removeROIs = roiChoice.get(0);

			//Increase the value of count by 1 i.e. how many ROIs we've removed
			count++;

		}
		
	}

//Not necessary anymore
	
/////////////////////////////////
		
	//Display the arrays from ROI clearing
	//IJ.log("roiNamesArray contains: " + table[0][0].toString());  
	//IJ.log("twoDAreaArray contains: " + table[0][1].toString());  
	//IJ.log("sliceAreaArray contains: " + table[0][2].toString());  
	
/////////////////////////////////

	//Make sure there are no selections on the mask image
	IJ.run(maskImage, "Select None", "");
	
	//Clear the selection of the last ROI
	IJ.run(image, "Select None", "");

	//Here we rename our mask image to how many times we've run the removeROI function, as at the end of all roi removals we need to be able to refer to the masks from each run
	timesRunString = Integer.toString(timesRun);
	maskImage.setTitle("Mask " + timesRunString);
	maskImage.show();	
	
	//Clear the roi manager
	rm.runCommand("Deselect");
	rm.runCommand("Delete");
	
}

//Here we create a custom class that will allow us to return both a string and checkbox value from the autoThreshTryAll function
public class returningValues {
	public final String threshChoice;
	public final Checkbox goodThresh;

	public returningValues(String threshChoice, Checkbox goodThresh) {
		this.threshChoice=threshChoice;
		this.goodThresh=goodThresh;
	}

	//This is how we return the string value i.e. returningValues.getThreshChoice();
	public String getThreshChoice() {
		return this.threshChoice;
	}

	//This is how we return the checkbox value i.e. returningValues.getGoodThresh();
	public Checkbox getGoodThresh() {
		return this.goodThresh;
	}
	
}

//Function to try all the autoThresh options and get user input after making a small substack of the input image
public static returningValues autoThreshTryAll(String imageTitle) {

	//Get the image associated with the input title
	avg = WindowManager.getImage(imageTitle);
			
	//Here we create a 20 slice substack of our smoothed, cleaned image, so that we can try out the auto thresholds on it
	threshTest = new Duplicator().run(avg, 1, 5);
	threshTest.show();

	//This runs the try all action for the auto threshold method
	IJ.run(threshTest, "Auto Threshold", "method=[Try all] white stack");
	threshStack = WindowManager.getImage("Stack");

	//These string arrays are for choosing which thresholding method to use
	String [] threshChoice =  {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"};
	String [] threshNames = {"Default", "Huang", "Huang2", "Intermodes", "IsoData", "Li", "MaxEntropy", "Mean", "MinError(I)", "Minimum", "Moments", "Otsu", "Percentile", "RenyiEntropy", "Shanbhag", "Triangle"};
			
	//Create a non-blocking dialog so the user can still check the image whilst choosing
	NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Auto Threshold Choice");
	userInputs.addChoice("Which panel worked the best?", threshChoice, "1");
	userInputs.addCheckbox("Tick if you're not happy with any of the options", false);
			
	userInputs.showDialog();
	
	//Close the stack of threshold test
	threshStack.close();

	//Get the choices from the dialog box and the associted thresholding method
	int choice = userInputs.getNextChoiceIndex();
	String threshSelected = threshNames[choice];
			
	goodThresh = userInputs.getCheckboxes();
	goodThreshChoice = goodThresh.get(0);	

	//Put these choices in the returningValues class
	returningValues output = new returningValues(threshSelected, goodThreshChoice);

	//Close the threshTest image
	threshTest.close();
		
	//Return this as output
	return output;
			
}

//Function for manual thresholding of an image avg
public static manualThresholding(avg) {

	//Start the manual thresholding commands and wait for the user to complete it
	new WaitForUserDialog("Manual thresholding", "Manually threshold the image then proceed").show();
	//If after thresholding the image has an inverted LUT, we flip it
	if(avg.isInvertedLut() == true) {
		IJ.run(avg, "Invert LUT", "");
	}
	//Now we check that the image foreground and background are correctly set
	new WaitForUserDialog("Check image", "Make sure that vessels are in white on a black background, then proceed").show();
}

public static replaceWithBackup(avg, backup) {
	String avgName = avg.getTitle();
	avg.changes = false;
	avg.close();
	backup.setTitle(avgName);
	avg = backup;
	avg.show();
}

public static dialogUserApproval(String dialogTitle, String dialogText) {
	NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog(dialogTitle);
	userInputs.addCheckbox(dialogText, true);
	userInputs.showDialog();
		
	FirstCheckBox = userInputs.getCheckboxes();
	FirstCheck = FirstCheckBox.get(0);

	return FirstCheck;
}

//Function for the entire thresholding and roi removal process of an image, avg
public static thresholdingGrandFunction(avg) {

	//Create a backup of the input image
	babyFresh=avg.duplicate();

	String avgName = avg.getTitle();
	
	//Get the pixel sizes and unit of calibration of the avg image
	pxlWidth = avg.Calibration.pixelWidth;
	pxlDepth = avg.Calibration.pixelDepth;
	unit = avg.Calibration.getUnit();

	//Not necessary anymore
	
	//IJ.log("roiNamesArray contains: " + roiDetails[0][0].toString());  
	//IJ.log("twoDAreaArray contains: " + roiDetails[0][1].toString());  
	//IJ.log("sliceAreaArray contains: " + roiDetails[0][2].toString()); 

	//Next stages here - add options for smoothing of images, and maybe don't bother with roi removal prior to first autothresh trial - maybe don't have any of that, just hvae the menu section?

	//If the autothresholding was bad..

	//We count how many times we've run the roiRemoval function so that we know how many outputs we have to deal with at the end of this function
	timesRun=0;

	//Create an array to store the maskImages output by the roiRemoval function
	ArrayList maskImages = new ArrayList();

	editImage=true;
	
	while(editImage == true) {

		//Ask the user to choose between these choices
		String [] choiceArray = {"Start from the beginning - remove all image edits","Remove ROIs", "Manually threshold the image", "Try an automated thresholding technique", "Smooth the image", };
			
		NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Processing");
		userInputs.addChoice("Watchu wanna do 'bout it?", choiceArray, "Start from the beginning - remove all ROI clearances and thresholding");
		userInputs.showDialog();

		int choice = userInputs.getNextChoiceIndex();

		//If the user chooses to try a different automated thresholding technique


		if(choice == 4) {
			
			backup = avg.duplicate();
			
			String [] smoothingArray = {"Gaussian Blur 3D", "Median 3D", "Mean 3D", "Minimum 3D", "Maximum 3D", "Variance 3D"};
			
			NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Smoothing");
			userInputs.addChoice("Which smoothing technique?", smoothingArray, "Gaussian Blur 3D");
			userInputs.addNumericField("Pixels to smooth in x: ", 0,0);
			userInputs.addNumericField("Pixels to smooth in y: ", 0,0);
			userInputs.addNumericField("Pixels to smooth in z: ", 0,0);
			
			userInputs.showDialog();

			int xSmooth = userInputs.getNextNumber();
			int ySmooth = userInputs.getNextNumber();
			int zSmooth = userInputs.getNextNumber();

			int smoothingMethod = userInputs.getNextChoiceIndex();

			IJ.run(avg, ""+smoothingArray[smoothingMethod]+"...", "x="+xSmooth+" y="+ySmooth+" z="+zSmooth+"");

			smoothFirstCheck = dialogUserApproval("Smoothing satisfactory?", "Happy with the smoothing?");

			if(smoothFirstCheck.getState() == true) {
				backup.close();
			} else {
				replaceWithBackup(avg, backup);
			}

		}
		
		if(choice == 3) {

			//Backup the input image and run the autoThreshTryAll function on the input
			backup = avg.duplicate();
			autoThreshFinal = autoThreshTryAll(avgName);
			String threshChoiceLoop = autoThreshFinal.getThreshChoice();
			Checkbox goodThreshChoiceLoop = autoThreshFinal.getGoodThresh();

			//If the user is happy with the threhsolding, then run it
			if(goodThreshChoiceLoop.getState() == false) {

				IJ.run(avg, "Auto Threshold", "method="+threshChoiceLoop+" white stack");

				//Check if the user is still happy
				threshFirstCheck = dialogUserApproval("Thresholding satisfactory?", "Happy with thresholding?");

				//If so, then close the backup image and we exit this whole condition by setting goodThreshChoice to false
				if(threshFirstCheck.getState() == true) {

					IJ.log("Checking what the skeleton looks like");
					IJ.run(avg, "Skeletonize (2D/3D)", "");

					//Check if the user is still happy
					skeletonFirstCheck = dialogUserApproval("Skeleton satisfactory?", "Happy with the skeleton?");

					if(skeletonFirstCheck.getState() == true) {

						editImage = false;
						backup.close();
					
					}
				}
			}

			if(goodThreshChoiceLoop.getState() == true || threshFirstCheck.getState() == false || skeletonFirstCheck.getState() == false) {
				replaceWithBackup(avg, backup);
			}
		}

		//If the user chooses the manually threhsold the image		
		if(choice == 2) {

			//Create a backup
			backup = avg.duplicate();

			//Run the manual threshlding function on the input
			manualThresholding(avg);

			//Check if the user is happy
			manualHappy = dialogUserApproval("Manual Thresholding", "Happy with the manual threshold?");

			//If happy, set goodThreshChoice to true and exit condition
			if(manualHappy.getState() == true) {	

				IJ.log("Checking what the skeleton looks like");
				IJ.run(avg, "Skeletonize (2D/3D)", "");

				//Check if the user is still happy
				skeletonFirstCheck = dialogUserApproval("Skeleton satisfactory?", "Happy with the skeleton?");

				if(skeletonFirstCheck.getState() == true) {

					editImage = false;
					backup.close();
					
				}
			}
			
			if(skeletonFirstCheck.getState() == false || manualHappy.getState() == false) {
				replaceWithBackup(avg, backup);
			}
		}

		//If the user chooses to remove more ROIs	
		if(choice == 1) {

			//Create a backup
			backup = avg.duplicate();

			//Artificailly create a ticked checkbox here to input into the function so the user doesn't have to bother doing it manually again
			roiRemovalTempBox = new Checkbox();
			roiRemovalTempBox.setState(true);
			test = String.valueOf(roiRemovalTempBox);
			IJ.log(test);
			
			//Run the roi removal function
			roiRemoval(avgName, roiRemovalTempBox, timesRun);	

			//Create a variable for the mask that was output by the function
			IJ.log("Mask " + Integer.toString((timesRun)));
			tempSelect = WindowManager.getImage("Mask " + Integer.toString((timesRun)));
			tempSelect.hide();
	
			//roiDetails[0][0].addAll(roiDetailsMore[0][0]);
			//roiDetails[0][1].addAll(roiDetailsMore[0][1]);
			//roiDetails[0][2].addAll(roiDetailsMore[0][2]);

			//Check if the user is happy with the result
			roiRemovalHappy = dialogUserApproval("ROI Removal", "Happy with the ROI removal?");

			//If they're happy, we close the backup and add the mask to our arrayList of masks and increase timesRun
			if(roiRemovalHappy.getState() == true) {				
				backup.close();
				maskImages.add(tempSelect);
				timesRun++;
			//Otherwise we close the input and the mask and set the backup to the main image
			} else {
				tempSelect.close();
				replaceWithBackup(avg, backup);
			}
				
		}

		//If the user wants to start from scratch with the image
		if(choice == 0) {	

			//Close the input image and set the backup as the main image so we go back to the menu with a fresh clean image
			replaceWithBackup(avg, babyFresh);

			babyFresh=avg.duplicate();

		}

	}
	
	//Now we check if the user has run the roiRemoval function, and if they have then we have to calculate the volume they've removed
	if(timesRun>0) {

		//A string to store the list of masks to use when adding them together
		StringBuilder imagesToUse  = new StringBuilder();
		
		//String to store the expression for the image expression parser plugin (i.e. adding the images together or subtracting etc., this plugin can do image calculation but for >2 images)
		StringBuilder expressionToUse = new StringBuilder();
	
		//String to store the correct command i.e. a=[image1] b=[image2] for use with the plugin
		String[] amendedAlphabetArray = new String[26];
	
		//Character array to store all the upercase alphabet characters
		char[] uppercaseAlpha = new char[26];
		//And one to store the lowercase letters
		char[] lowercaseAlpha = new char[26];
	
		//Populate the uppercaseAlpha array with uppercase letters
		for(i = 0; i < 26; i++){
		    uppercaseAlpha[i] = (char)(65 + i);
		}
	
		//Same for lowercase - except fill the amendedAlphabetArray with the lowercase + =[
		for(i = 0; i < 26; i++){
			lowercaseAlpha[i] = (char)(97 + i);
			amendedAlphabetArray[i] = lowercaseAlpha[i]+"=[";
		}
	
		//Loop through the number of times we've run roiRemoval
		for(roisRun = 0; roisRun <timesRun; roisRun++){
			IJ.log("Looking for: Mask " + Integer.toString(roisRun));
			tempSelect = maskImages.get(roisRun);
			tempSelect.show();
			currentImageName = tempSelect.getTitle();
			
			//Get the current amended letter associated with the current roisRun value
			currentLetter = amendedAlphabetArray[roisRun];
			
			//Add a ] to the end of it
			stringToAdd=currentImageName+"] ";
			wholeBit=currentLetter+stringToAdd;
	
			//Add this to the imagesToUse StringBuilder and build up a string of all these
			imagesToUse.append(wholeBit);
	
			//If we aren't at the final roisRun value, put in the uppercase current letter with a +
			if(roisRun!=(timesRun-1)){
				expressionToUse.append(uppercaseAlpha[roisRun]+"+");
			//Else just add the letter without the +	
			} else {
				expressionToUse.append(uppercaseAlpha[roisRun]);
			}
		}
	
		//Turn the StringBuilder values into strings
		String imagesList = imagesToUse.toString();
		String expression = expressionToUse.toString();
	
		//Print the strings to see them
		IJ.log(imagesList);
		IJ.log(expression);
	
		//Run the image expression parser using the built strings
		IJ.run("Image Expression Parser (Macro)", "expression="+expression+" "+imagesList+"");

		//We get the output of the parser
		parsedImageVirt = IJ.getImage();
		//Then we duplicate it (so that the duplicate is no longer a virtual stack)
		parsedImage=parsedImageVirt.duplicate();
		//Then we close the original
		parsedImageVirt.close();
		//And show the duplicate
		parsedImage.show();
		//Then we get the name of the image
		currentImageName = parsedImage.getTitle();

		//We then loop through the number of times we've run the roiRemoval and close all the associated mask windows
		for(roisRun = 0; roisRun <timesRun; roisRun++){
			tempSelect = maskImages.get(roisRun);
			tempSelect.close();
		}

		//We then invert and 8-bit the parsed image output (the sum of all mask windows
		IJ.run(parsedImage, "Invert", "stack");
		IJ.run(parsedImage, "8-bit", "");

		//Get the pixel sizes and unit of calibration and number of slices of the avg image
		pxlWidth = avg.Calibration.pixelWidth;
		pxlDepth = avg.Calibration.pixelDepth;
		unit = avg.Calibration.getUnit();
		totalSlices=avg.getNSlices();

		//Calibrate the parsed image
		IJ.run(parsedImage, "Properties...", "channels=1 slices="+totalSlices+" frames=1 unit="+unit+" pixel_width="+pxlWidth+" pixel_height="+pxlWidth+" voxel_depth="+pxlDepth+"");
			
		//Run the voxel counter
		IJ.run(parsedImage, "Voxel Counter", "");
		//Get out the number of voxels counted as a double array, voxelCount
		ResultsTable rt = ResultsTable.getResultsTable();
		voxelCount = rt.getColumnAsDoubles(0);
		
		//Loop through all the values in voxelCount and tally up how many total voxels have been cleared
		total = 0;
		for(voxelTotalVar=0; voxelTotalVar<totalSlices; voxelTotalVar++) {
			total = total + voxelCount[voxelTotalVar];
		}
		
		IJ.log("Total voxels: " + IJ.d2s(total, 3));
		
		//Calculate the volume occupied by a single voxel using calibrated values of width and depth
		voxelVolume=(pxlWidth*pxlWidth*pxlDepth);
		
		//Calculate the total volume of the image cleared by the rois
		volumeRemoved=voxelVolume*total;
	
		IJ.log("Calculated space removed by ROIs");	
		IJ.log("Pixel width: " + IJ.d2s(pxlWidth, 9) + " Pixel depth: " + IJ.d2s(pxlDepth,9) + " Voxel Volume: " + IJ.d2s(voxelVolume,9));
		IJ.log("Volume removed: " + IJ.d2s(volumeRemoved, 9) + "um^3");

		//Don't save changes to the parsed image, and close it
		parsedImage.changes = false;
		parsedImage.close();

	//If no roi removals were done
	} else {

		//Set the volume removed to nothing
		double volumeRemoved=0;	
	
		IJ.log("No space removed by ROIs");
		IJ.log("Volume removed: " + IJ.d2s(volumeRemoved,9) + "um^3");
	
	}

	//Return how much volume of the image we removed by roi clearing
	return volumeRemoved;
	
}

//Example inputs for the function (called a method in java?)
//String dir = "E:/Dropbox (Brain Energy Lab)/Everything/2P data/Devin/";
String dir = "/Users/Devin/Downloads";
String toFind = "WideFOV";

//Declare the arrraylist to fill outside the function
ArrayList fileLocations = new ArrayList();

//Here we return the output of the method into a file array
System.out.println("Start");
File [] output = listFilesAndFilesSubDirectories(dir, toFind, fileLocations);
System.out.println("End");

//Here we create a dialog box for user input
//choiceArray is a list of channels the user can select
//channelNames are the associated substrings with those channels
String [] choiceArray =  {"1", "2", "3", "4"};
String [] channelNames = {"ch_1", "ch_2", "ch_3", "ch_4"};

GenericDialog userInputs = new GenericDialog("User Inputs");
userInputs.addNumericField("Number of frames per plane: ", 0, 0);
userInputs.addChoice("Which channel to use", choiceArray, "2");
userInputs.showDialog();

//Retrive the choices as integers, or as a string in the case of channel
int choice = userInputs.getNextChoiceIndex();
int FperZ = userInputs.getNextNumber();
String channel = channelNames[choice];

//Here we go through our list of file locations and open ones that include ch_2 (i.e. they are TexasRed) if selected channel is 2
for (File file:output) {
	if(file.getAbsolutePath().contains(channel)) {
		imp=IJ.openImage(file.getAbsolutePath());
		String name = imp.getTitle();
		impSlices=imp.getNSlices();

		remainder = impSlices%FperZ;
		
		//imp.show();
		//String [] test = WindowManager.getImageTitles();
		//System.out.println(test[0]);
		//System.out.println(name);
		//here = WindowManager.getImage(name);
		//System.exit();	
		
		//Here we register the open image then grouped z project it according to the user input of how many frames per Z were taken
		IJ.run(imp, "MultiStackReg", ""+name+" action_1=Align file_1=[] stack_2=None action_2=Ignore file_2=[] transformation=Translation");

		//This isn't working  - fix

		if(false) {

		while(remainder!=0){
			GenericDialog userInputs = new GenericDialog("Not divisible by frame averaging value");
			userInputs.addNumericField("Number of frames per plane: ", 0, 0);
			userInputs.showDialog();
			
			int FperZ = userInputs.getNextNumber();

			remainder = impSlices%FperZ;

			}

		}
		
		IJ.run(imp, "Grouped Z Project...", "projection=[Average Intensity] group="+FperZ+"");
		imp.close();
		
		//Here we get the averaged image and set it as avg
		String avgName = "AVG_"+name;
		avg = WindowManager.getImage(avgName);
		
		//Turn avg into an 8 bit image
		IJ.run(avg, "8-bit", "");

		calibratedUnit = avg.getCalibration().getXUnit();

		//If the image isn't calibrated in um, prompt the user to calibrate it in um until it is
		while(calibratedUnit!="Âµm") {	
			new WaitForUserDialog("Calibration", "Calibrate the image into um in the next window").show();
			IJ.run(avg, "Properties...", "");
			calibratedUnit = avg.getCalibration().getXUnit();
			}

		roiVolumeRemoved = thresholdingGrandFunction(avg);

		avg = WindowManager.getImage(avgName);

		IJ.log("ROI Volume Removed: " + IJ.d2s(roiVolumeRemoved, 9));

		System.exit();	
		//IJ.run(avgNameSmooth, "Analyze Skeleton (2D/3D)", "prune=[lowest intensity voxel] show display original_image="+dupName+"");
		IJ.run(avg, "Analyze Skeleton (2D/3D)", "prune=[shortest branch] show display");
		
		//test.close();

		tifIndex = dupName.indexOf(".tif");
		String skeletonName = dupName.substring(0, tifIndex) + "-labeled-skeletons";
		skelWindow = WindowManager.getImage(skeletonName);
		//skelWindow.close();

		//String [] test = WindowManager.getImageTitles();
		//System.out.println(skeletonName);
		//System.out.println(test[0]);
		//System.out.println(test[1]);
		//System.out.println(test[2]);
		//System.out.println(test[3]);
		//System.out.println(test[4]);
		
		System.exit();	
		}
}
