//Written by Devin 10/9/18 updated 4/10/18
//Code for taking 2P vessel morphology stacks, processing them, and outputting a distance map and 3d skeleton coordinates for use with matlab
//to find diameters and vessel density etc.

//User inputs: the directory where 2P vessel morphology images are stored, and which string is used to identify them
//The macro assumes all images in the directory selected are in the same channel, so move images with vessels in different channels to different directories

//Dependencies:
//Skeletonizes 2D/3D and analyze skeleton
//Voxel Counter and MultiStackReg

import ij.IJ; //Import this so that we can use imageJ to open the image
import ij.gui.GenericDialog;//Import so we can create dialog boxes
import ij.gui.WaitForUserDialog;//Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.ImagePlus;//Import to allow us to create or alter images
import ij.WindowManager;//Import to allow us to manager windows
import ij.measure;//Import so we can measure things
import ij.measure.Calibration; //Import so we can access and set calibration values
import ij.measure.ResultsTable; //Import so we can access the results table
import ij.plugin.Duplicator; //Import so we can create substacks using the duplicator
import ij.process.ImageProcessor; //Import so we can invert the LUT after thresholding
import ij.plugin.PlugIn; //Import so we can save things without prompting to save changes
import ij.plugin.frame.RoiManager; //Import so we can work with the roi manager
import ij.io.DirectoryChooser; //Import so the user can select a directory from a dialog box

//Import these so we can use analyze skeleton
import sc.fiji.analyzeSkeleton.AnalyzeSkeleton_;
import sc.fiji.analyzeSkeleton.Edge;
import sc.fiji.analyzeSkeleton.Point;

//Argsin are the directory to search and the substring to search for
public static listFilesAndFilesSubDirectories(String directoryName, String substring) {

	//Here we declare our listOfFiles as a file array containing the list of files in the directoryName
	File [] listOfFiles = new File(directoryName).listFiles();

	//Arraylist to add our file locations to
	ArrayList fileLocations = new ArrayList();

	//Loop through the files in the file list
	for (File file:listOfFiles) {
		//If the file we're checking is a file and not a directory and if it contains the substring we're interested in within its full path
		//We check against the absolute path of our file in lower case on both counts
		if (file.isFile() && file.getAbsolutePath().toLowerCase().contains(substring.toLowerCase())) {
			//We store the full path in the output ArrayList;
			fileLocations.add(file.getAbsoluteFile());
			//IJ.log(file.getAbsolutePath());
		//If the file we're checking is a directory, then we run the whole thing on that directory
		} else if (file.isDirectory()) {
			File[] outputArray = listFilesAndFilesSubDirectories(file.getAbsolutePath(), substring); 
			for(i=0; i<outputArray.length; i++) {
				fileLocations.add(outputArray[i]);	
			}
		}
	}

	//Here we convert out ArrayList to a file array and return it
	File[] arrayForm = fileLocations.toArray(new File[0]);
	
	return arrayForm;
}

//Argsin are just the title of the image to be ROI edited, and how many times the function has been run before
public static roiRemoval(image, int timesRun) {

	//Create an arraylist to store the beginning and ending slices set by the user for each roi
	ArrayList slicesToRemove = new ArrayList();

	//Create variable to count how many ROIs we create
	int count = 0;

	//Get the dimensions of the image, and create a new blank image in the same dimensions that will store the masks of the rois created
	//[0] = width; [1] = height; [3] = slices
	
	int[] imageDimensions = image.getDimensions();
	maskImage = IJ.createImage("Mask", "8-bit black", imageDimensions[0], imageDimensions[1], imageDimensions[3]);

	//Open the ROI manager and create a variable to refer to the open instance
	IJ.run("ROI Manager...", "");
	RoiManager rm = RoiManager.getInstance();

	//Set this condition to true, and only stop roiRemoval process when it is set to false by the user
	removeROIs = true;

	//Show the input image
	image.show();
		
	//While true, enter the roi removal condition
	while (removeROIs == true) {
			
		//Ask the user to draw around what they want to remove and to go to the slice to start the removal from
		new WaitForUserDialog("ROI selection", "Draw a ROI to exclude from image if desired, and set the stack to the slice you want to start at").show();
			
		//Get the number of the slice set
		int startSlice = image.getSlice();

		//Get the slice chosen by the user at the end
		new WaitForUserDialog("ROI selection", "Set the slice where you want the ROI to end").show();
		int endSlice = image.getSlice();

		//If the endslice is set before the start then we go back to the start of the loop and show an error message
		if(endSlice<=startSlice) {
				
			new WaitForUserDialog("Slice error", "End slice was set before the start slice").show();
			
			} else {

			//Once the roi is drawn we add it to our roi manager
			rm.addRoi(image.getRoi());

			//We also add our start and end slices to our slicesToRemove arrayList
			slicesToRemove.add(startSlice);
			slicesToRemove.add(endSlice);

			//We show our mask image as we need this in order to clear it and this way keep a record of what we've cleared
			maskImage.show();
				
			//Loop through the slices from start to end, each time clearing the area within the ROI in our input and mask images image
			for (int clearSlice = startSlice; clearSlice <= endSlice; clearSlice++) {
				//Input image
				image.setSlice(clearSlice);
				IJ.run(image, "Clear", "slice");
				IJ.run(maskImage, "Select None", "");

				//Mask image
				IJ.selectWindow("Mask");
				RoiManager rm = RoiManager.getInstance();
				rm.select(count);
				maskImage.setSlice(clearSlice);
				IJ.run(maskImage, "Fill", "slice");		
			}

			//Hide the mask image until necessary again
			maskImage.hide();	
	
			//Create a dialog to ask the user whether they want to manually remove any more ROIs - if yes we repeat the loop
			removeROIs = dialogUserApproval("Cleaning Image", "Do you want to manually remove another ROI from the image?");

			//Increase the value of count by 1 i.e. how many ROIs we've removed
			count++;

		}
		
	}

	//Make sure there are no selections on the mask image
	IJ.run(maskImage, "Select None", "");
	
	//Clear the selection of the last ROI on the input image
	IJ.run(image, "Select None", "");

	//Here we rename our mask image to how many times we've run the removeROI function, as at the end of all roi removals we need to be able to refer to the masks from each run
	maskImage.setTitle("Mask " + Integer.toString(timesRun));

	//We need to show the mask here as in order to add it to the arraylist it must be shown
	maskImage.show();	
	
	//Clear the roi manager
	rm.runCommand("Deselect");
	rm.runCommand("Delete");

	//return the mask image for easy reference outside the function
	return maskImage;
	
}

//Function to try all the autoThresh options and get user input after making a small substack of the input image
public static autoThreshTryAll(avg) {
			
	//Here we create a 5 slice substack of our smoothed, cleaned image, so that we can try out the auto thresholds on it
	threshTest = new Duplicator().run(avg, 1, 5);
	threshTest.show();

	//This runs the try all action for the auto threshold method
	IJ.run(threshTest, "Auto Threshold", "method=[Try all] white stack");
	threshStack = WindowManager.getImage("Stack");

	//These string arrays are for choosing which thresholding method to use
	//Each index in threshChoice corresponds to the method in threshNames
	String [] threshChoice =  {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"};
			
	//Create a non-blocking dialog so the user can still check the image whilst choosing
	//Ask the user which threshold option worked best, and also whether none of them are good
	NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Auto Threshold Choice");
	userInputs.addChoice("Which panel worked the best?", threshChoice, "1");
	userInputs.addCheckbox("Tick if you're not happy with any of the options", false);
			
	userInputs.showDialog();
	
	//Close the stack of threshold test
	threshStack.close();

	//Get the choices from the dialog box and the associted thresholding method
	int choice = userInputs.getNextChoiceIndex()+1;

	//Get whether the user is happy with the threshold options 
	goodThreshChoice = userInputs.getCheckboxes().get(0).getState();	

	//If the user isn't happy with any of the choices, set the threshold selected to 0
	if(goodThreshChoice == true) {
		choice = 0;
	}

	//Close the threshTest image
	threshTest.close();
		
	//Return the thresh selected
	return choice;
			
}

//Function for manual thresholding of an image
public static manualThresholding(avg) {

	//Ask the user to do their own manual thresholding, and click ok when done
	new WaitForUserDialog("Manual thresholding", "Manually threshold the image then proceed").show();
	//If after thresholding the image has an inverted LUT, we flip it
	if(avg.isInvertedLut() == true) {
		IJ.run(avg, "Invert LUT", "");
	}
	//Now we ask the user to check that the image foreground and background are correctly set
	new WaitForUserDialog("Check image", "Make sure that vessels are in white on a black background, then proceed").show();

	//Check if the user is happy with the outcome of the manual thresholding
	manualHappy = dialogUserApproval("Manual Thresholding", "Happy with the manual threshold?");

	//Return their choice
	return manualHappy;
	
}

//This is to replace the image avg with another image backup so that for all variable and title purposes backup is now avg
public static replaceWithBackup(avg, backup) {
	
	//Get the title of avg, close it without changes, set backup to the same title and reassign it to the avg variable and return it
	String avgName = avg.getTitle();
	avg.changes = false;
	avg.close();
	backup.setTitle(avgName);
	avg = backup;
	avg.show();

	return avg;
}

//This is to get the user's approval, a simple dialog box with a single check box, and we return the boolean of the checkbox - inputs are just strings for the
//title of the dialog box and the checkbox itself
public static dialogUserApproval(String dialogTitle, String dialogText) {
	NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog(dialogTitle);
	userInputs.addCheckbox(dialogText, true);
	userInputs.showDialog();

	//We get a vector of checkbox choices, then get the first checbox choice, then get its state to get the boolean out
	checkboxBoolean = userInputs.getCheckboxes().get(0).getState();

	return checkboxBoolean;
}

//Function to skeletonise the image and then create 3D projections of the skeletonised image and the backup image to help the user asses the quality of skeletonisation
//User is also given the option to edit the skeleton and either proceed or revert back to the non-skeletonised image for further edits
//Image is the skeleton, backup is a raw non-skeletonised, non thresholded image, timesRun is how many times removeRois has been run, and maskImages is the arraylist of
//the mask images we've generated from removeRois
public static skeletonChecking(image, backup, int timesRun, ArrayList maskImages) {		

	//This variable stores whether the user is happy or with the skeleton after editing - if happy it gets set to 1, otherwise to 0, so if it remains set
	//at 2 we know the user didn't edit the image
	int skelGood=2;
	
	//Skeletonise the input image
	IJ.run(image, "Skeletonize (2D/3D)", "");

	//Get the calibration in Z of the input image
	imageZSize = image.getCalibration().pixelDepth;

	//Create 3D projections of the raw image (backup) and the skeleton to help the user assess skeleton
	IJ.run(image, "3D Project...", "projection=[Brightest Point] axis=Y-Axis slice="+imageZSize+" initial=0 total=360 rotation=10 lower=1 upper=255 opacity=0 surface=100 interior=50");
	threeDImage = IJ.getImage();
	threeDImageTitle=threeDImage.getTitle();

	IJ.run(backup, "3D Project...", "projection=[Brightest Point] axis=Y-Axis slice="+imageZSize+" initial=0 total=360 rotation=10 lower=1 upper=255 opacity=0 surface=100 interior=50");
	threeDImageRaw = IJ.getImage();

	//Show the raw image
	image.show();

	//Check if the user is happy with the skeleton
	skeletonFirstCheck = dialogUserApproval("Skeleton satisfactory?", "Happy with the skeleton?");
	
	//If the user was happy
	if(skeletonFirstCheck == true) {

		//Close the 3D projections and the backup
		threeDImageRaw.close();
		backup.close();
		threeDImage.close();

	//If not
	} else {

		//choiceMade is whether we've made a choice re: the final outcome of the skeleton after editing, set to false initially
		choiceMade = false;

		//Whilst we haven't made a final choice, we enter this condition
		while(choiceMade == false) {

			//Show the skeleton
			image.show();

			//If the 3D skeleton isn't open already (will be open during first run, but not during subsequent loops) then run the 3D projeciton of it and
			//reassign the variables to it
			if(WindowManager.getWindow(threeDImageTitle)==null) {
				IJ.run(image, "3D Project...", "projection=[Brightest Point] axis=Y-Axis slice="+imageZSize+" initial=0 total=360 rotation=10 lower=1 upper=255 opacity=0 surface=100 interior=50");
				threeDImage = IJ.getImage();
			}

			//Here we create a dialog box with the following options seen in the string array
			String [] skeletonEditChoices = {"Despeckle the skeleton", "Remove parts of the skeleton", "Proceed with skeleton as is", "Return to the non-skeletonised image to make changes"};

			//Ask the user for their choices
			NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Skeleton editing");
			userInputs.addChoice("Skeleton editing options", skeletonEditChoices, "Remove parts of the skeleton");
					
			userInputs.showDialog();			
		
			skelEdit = userInputs.getNextChoiceIndex();

			//Close the 3D image - we'll generate a new one on the next iteration if the final choice isn't made
			threeDImage.close();

			//If the user wants to despeckle the skeleton
			if(skelEdit == 0) {

				//Backup the skeleton
				skelEditBackup = image.duplicate();	

				//Despeckle the image
				IJ.run(image, "Despeckle", "stack");

				//Find out if the user is happy with the despeckle
				skelDespeckleHappy = dialogUserApproval("Skel despeckle", "Happy with the despeckle?");

				//If so, close the backup and go back to the menu, otherwise replace the skeleton with the backup and go back to the menu
				if(skelDespeckleHappy == true) {
					skelEditBackup.close();
				} else {
					image = replaceWithBackup(image, skelEditBackup);
				}
				
			//if the user wants to remove bits of the skeleton
			} else if (skelEdit==1) {

				//We create a backup of the image then run the roiRemoval function
				skelEditBackup = image.duplicate();	
				roiMask = roiRemoval(image, timesRun);

				//Find out if the user is happy with the removal
				skelRoiRemovalHappy = dialogUserApproval("ROI Removal", "Happy with the ROI removal?");	

				//If so, we add the mask image to the arrayList of created mask images, increase timesRun, and close the backup we previously made
				if(skelRoiRemovalHappy == true) {
					maskImages.add(roiMask);
					timesRun++;
					skelEditBackup.close();
					roiMask.hide();
				//Else we close the mask and replace our roiRemoved image with our backup image using the replaceWithBackup function
				} else {
					roiMask.close();
					image = replaceWithBackup(image, skelEditBackup);
				}

			//If the user has made a final choice, set choiceMade to true and close the raw 3d image
			} else if(skelEdit==2 || skelEdit ==3) {
				choiceMade = true;
				threeDImageRaw.close();
			}

			//If the user is happy with the skeleton, skelgood = 1 and we close the non-thresholded backup
			if(skelEdit==2) {
				skelGood = 1;
				backup.close();
			//Otherwise skelgood = 0
			} else if (skelEdit==3) {
				skelGood = 0;
			}

		}

	}

	//ArrayList to save the choices the user makes
	ArrayList choices = new ArrayList();

	//Return whether the user was happy with the first skeleton check, and then if they were happy after editing, and how many times roiRemoval was run
	choices.add(skeletonFirstCheck);
	choices.add(skelGood);
	choices.add(timesRun);

	return choices;

}

//This looks for the string toCheck within the file array parentFiles, and if it finds it, alters to toAlter int to 1
//Used for taking an int variable set to 0 and setting it to 1 if we find a file with the toCheck string
public static lookingForSomething(File [] parentFiles, int toAlter, String toCheck) {
	for(File statusCheck:parentFiles) {
		//We lowercase the toCheck and the filepath to avoid any case sensitivity to checking
		//If they match, we print the name that matches and set the toAlter variable to 1 and break after finding the first file
		if(statusCheck.getAbsolutePath().toLowerCase().contains(toCheck.toLowerCase()) == true) {
			IJ.log(statusCheck.getName());
			toAlter = 1;
			break;
		}
	}
	//Return the final value of toAlter
	return toAlter;
}

//Function to calculate the volume removed by roiremoval - uses an input of parsedImage which is a mask image of all cleared rois - black pixels are counted
//so this needs to be a condition
//Voxelvolume is the size of a voxel in calibrated units
public static calculateVolRemoved(parsedImage, voxelVolume) {

	//Run the voxel counter - counts all the voxels in black
	IJ.run(parsedImage, "Voxel Counter", "");
	//Get out the number of voxels counted as a double array, voxelCount
	ResultsTable rt = ResultsTable.getResultsTable();
	voxelCount = rt.getColumnAsDoubles(0);

	totalSlices=parsedImage.getNSlices();
						
	//Loop through all the values in voxelCount and tally up how many total voxels have been cleared
	total = 0;
	for(voxelTotalVar=0; voxelTotalVar<totalSlices; voxelTotalVar++) {
		total = total + voxelCount[voxelTotalVar];
	}
	
	//Calculate the volume removed by taking the total X voxelVolume
	volumeRemoved=voxelVolume*total;

	//Return the volume removed
	return volumeRemoved;

}

//Here we define a class skeletonValues that will contain the radius, skeleton, branch, and coordinate number for each coordinate in our skeleton - we do this so we can sort this data
//by skeleton, then branch, then coordinate number, so that it matches our skeleton coordinate data so we simply have to append our radius to that data rather than search that data
//to find which coords the radius belongs to

//All this sorting code was adapted from http://techthinking.net/2010/04/how-to-sort-two-dimensional-data-based-on-multiple-parameters/
class skeletonValues {

	double xCoord;
	double yCoord;
	double zCoord;
	double xCal;
	double yCal;
	double zCal;
	double skelNo;
	double branchNo;
	double coordNo;
	double radius;

	//Order of the data in skeletonValues is determined by the order of the data we get out of our 3d skeleton coordinates, which is:
	//[0] is x coord, [1] is y, [2] is z, [3] to [5] is calibrated, [6] to [8] is skel, branch and coord, [9] is radius
	
	//Here a skeletonValues object contains the skelValues double array, so each skelValues object has 10 data points, and we define how to get our the radius, skelNo, branchNo, and coordNo from this data
	public skeletonValues(double xCoord, double yCoord, double zCoord, double xCal, double yCal, double zCal, double skelNo, double branchNo, double coordNo, double radius) {
		super();
		this.skelNo = skelNo;
		this.branchNo = branchNo;
		this.coordNo = coordNo;
		this.radius = radius;
	}
}

//This creates a comparator object that returns whether the skeletonvalues at two skeletonValues points (a1 and a2) are different or equal by altering the returned int accordingly
static final Comparator ORDER_BY_SKELNAME = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.skelNo<a2.skelNo) {
			return -1;
		} else if (a1.skelNo>a2.skelNo) {
			return 1;
		} else if (a1.skelNo == a2.skelNo) {
			return 0;
		}
	}
};

//Comparator to compare a1 and a2 on branch number
static final Comparator ORDER_BY_BRANCHNO = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.branchNo<a2.branchNo) {
			return -1;
		} else if (a1.branchNo>a2.branchNo) {
			return 1;
		} else if (a1.branchNo == a2.branchNo) {
			return 0;
		}
	}
};

//Comparator to compare coord numbers between a1 and a2
static final Comparator ORDER_BY_COORD = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		if(a1.coordNo<a2.coordNo) {
			return -1;
		} else if (a1.coordNo>a2.coordNo) {
			return 1;
		} else if (a1.coordNo == a2.coordNo) {
			return 0;
		}
	}
};

//This creates a final comparator which is a summary of the comparators we've previously defined - essentially, if skelNo matches, we order by branchNo, if that matches we order by Coord, else we stop at whichever
//step the values don't match

//The reason we're using comparators here is so we can use Arrays.sort(T[] a, Comparator<? super T> c) where we can input an array and then use a comparator to sort it - the ORDER_BY_RULES comparator is
//essentially a summary of all the others and so allows us to sort by multiple columns
static final Comparator ORDER_BY_RULES = new Comparator() {
	public int compare(skeletonValues a1, skeletonValues a2) {
		int i = ORDER_BY_SKELNAME.compare(a1, a2);
		if(i == 0){
			i = ORDER_BY_BRANCHNO.compare(a1, a2);
			if(i == 0){
				i = ORDER_BY_COORD.compare(a1, a2);
			}
		}
		return i;
	}
};

//Ask the user to select the directory we want to look within for our 2P vessel morphology images and get this out as a string
DirectoryChooser userDir = new DirectoryChooser("Select 2P Vessel Morphology Directory");
String dir = userDir.getDirectory();

String [] channelSelection = {"1", "2", "3", "4"};
String [] channels = {"ch_1", "ch_2", "ch_3", "ch_4"};

//Ask the user to input the string they want to use to identify 2P vessel morphology experiments
GenericDialog userInput  = new GenericDialog("User Inputs");
userInput.addStringField("String to identify vessel morphology experiments", "WideFOV", 8);
userInput.addChoice("Which channel are the vessels in?", channelSelection, "2");
userInput.showDialog();

//Return this input as a lower case string
String toFind = userInput.getStringFields().get(0).getText().toLowerCase();

//Get channel chosen by the user
int channelChoice = userInput.getNextChoiceIndex();

//Find files in the chosen directory that contain our string toFind
File[] output = listFilesAndFilesSubDirectories(dir, toFind);

int length = output.length;
IJ.log("Number of matching files found: " + Integer.toString(length));

//Here we go through our list of file locations and open ones that include ch_2 (i.e. they are TexasRed) if selected channel is 2
for (File file:output) {

	if(file.getAbsolutePath().contains(channels[channelChoice])) {
		
		//Here we get the parent directory that our wideFOV ch2 image is in and find its associated ini file
		File parentDirFile = file.getParentFile(); //File form to be used in making array of files from this directory
		String parentDir = file.getParent(); //String form for use in saving images

		//This is a list of all the files in the parent directory
		File[] parentFiles = parentDirFile.listFiles();

		//We create these variables to determine whether we've done thresholding, distance mapping, and skeleton analysis for the current image in question
		//and set to 0 by default
		thresholdingDone = 0;
		distanceMapDone = 0;
		skeletonDone = 0;

		IJ.log("Analyzing image: " + file.getAbsolutePath());

		//If we find any image containing the string thresholdedimage in our directory, set thresholdingdone to 1, otherwise all will be set to 0 as we need
		//the thresholded image to complete any of the other steps
		thresholdingDone = lookingForSomething(parentFiles, thresholdingDone, "thresholdedimage");

		//If the thresholded image exists, we look for a dmap file, and if we find it, set distanceMapDone to 1, but otherwise it and skeletondone will remain
		//at 0 as to do the skeleton we will have had to already do the distance map
		if(thresholdingDone == 1) {
			IJ.log("Thresholding of image already done");
			distanceMapDone = lookingForSomething(parentFiles, distanceMapDone, "dmap");
		}

		//Finally, if the distance map was done, we look for the skeleton coordinates, and if they exist, set skeleton done to 1
		if(distanceMapDone == 1) {
			IJ.log("Distance map of image already created");
			skeletonDone = lookingForSomething(parentFiles, skeletonDone, "3dcoords");
		}

		//If the skeleton hasn't been analyzed (so if we haven't completely finished analysing the image)
		if(skeletonDone == 0) {
		
			//We loop through the files in the parent directory and if any of them are an ini file
			for(File iniCheck:parentFiles) {
				if(iniCheck.getAbsolutePath().toLowerCase().contains("ini")) {
					
					IJ.log("Getting calibration values from ini file");
					IJ.log("Ini file: " + iniCheck.getAbsolutePath());
					
					//We open the ini file as a string and retrieve the indices of the x, y, and z pixel sizes, as well as the number of frames per plane
					//in addition we find the indices of the info that follows from those we're interested in so we can use them to cut substrings
					iniText = ij.IJ.openAsString(iniCheck.getAbsolutePath());

					String[] iniValueStrings = {"x.pixel.sz = ",
												"y.pixel.sz = ",
												"z.spacing = ",
												"frames.per.plane = "};

					int[] iniTextIndicesPreAdds = {13,13,12,15,19};

					ini[] iniVariables = new double [5];
					
					iniTextLength = iniText.length();

					for(i=0; i<iniValueStrings.length; i++) {
						startPoint = iniText.indexOf(iniValueStrings[i]) + iniTextIndicesPreAdds[i];
						for(i0=startPoint; i0<iniTextLength; i0++) {
							if(iniText.substring(i0, i0+1).matches(" ")) {
								newString = iniText.substring(startPoint, i0);
								lastIndex = newString.lastIndexOf("0");
								realString = newString.substring(0, lastIndex);
								if(i<2) {
									iniVariables[i] = Double.valueOf(realString).doubleValue() * (1e6);
								} else {
									iniVariables[i] = Double.valueOf(realString).doubleValue();
								}
								IJ.log(IJ.d2s(iniVariables[i], 9));
								i0 = iniTextLength;
							}
						}
					}

					//Here we declare variables for our frames per z, and our pixels sizes, as these will be filled in by the code immediately after, but are needed
					//beyond this section
					//Here we convert our FperZ into an int, as no point in a double - it has to be an integer value
					int FperZ = (int) iniVariables[4];
					double xPxlSize = iniVariables[0];
					double yPxlSize = iniVariables[1];
					double zPxlSize = iniVariables[2];
				
				}
			}
		} else {
			IJ.log("Skeleton of image already created");
		}

		//Here we declare some variables again, because we need them in multiple scopes - these are for the frame averaged image, the thresholded image, 
		//and the parsedImage - the image containing masks of all rois removed
		ImagePlus avg;
		ImagePlus thresholdedImage;
		ImagePlus parsedImage;

		//We declare our array to contain our image dimensions, as well as the individual variables we'll use to store them
		int[] avgDimensions;
		int avgWidth;
		int avgHeight;
		int avgChannels;
		int avgSlices;
		int avgFrames;

		//Declare the volume of our avg image, and also the volume removed by rois - we set this to 0 when declaring as if unchanged, then we haven't
		//removed any rois and this is valid
		double avgVolume;
		double volumeRemoved = 0;	

		//If the image hasn't been thresholded - the first step in processing
		if(thresholdingDone == 0) {

			IJ.log("Thresholding not done");

			//We open the image and get it's name
			imp=IJ.openImage(file.getAbsolutePath());
			String name = imp.getTitle();

			IJ.log("Registering image");
		
			//Here we register the open image using the translation technique
			IJ.run(imp, "MultiStackReg", ""+name+" action_1=Align file_1=[] stack_2=None action_2=Ignore file_2=[] transformation=Translation");

			IJ.log("Group Z Projecting image");
			
			//We show the image before group Z projecting it and then closing it
			imp.show();
			IJ.run(imp, "Grouped Z Project...", "projection=[Average Intensity] group="+FperZ+"");
			imp.close();
				
			//Here we get the averaged image and set it as avg and retrieve the image with the avg name
			String avgName = "AVG_"+name;
			avg = WindowManager.getImage(avgName);

			IJ.log("Converting to 8-bit");
		
			//Turn avg into an 8 bit image
			IJ.run(avg, "8-bit", "");

			//Here we fill our variables with the dimensions of the average image etc.
			avgDimensions = avg.getDimensions();
			avgWidth = avgDimensions[0];
			avgHeight = avgDimensions[1];
			avgChannels = avgDimensions[2];
			avgSlices = avgDimensions[3];
			avgFrames = avgDimensions[4];

			//Calculate the volume of the average image
			avgVolume = avgWidth*avgHeight*avgSlices*xPxlSize*yPxlSize*zPxlSize;
			

			IJ.log("Calibrating image with ini values");
			
			//Calibrate the average image according to the values taken from the ini file
			IJ.run(avg, "Properties...", "channels="+avgChannels+" slices="+avgSlices+" frames="+avgFrames+" unit=µm pixel_width="+xPxlSize+" pixel_height="+yPxlSize+" voxel_depth="+zPxlSize+"");

			//Create a backup of the input image that we can revert to during image processing if we want a clean slate
			babyFresh=avg.duplicate();
			
			//We count how many times we've run the roiRemoval function so that we know how many outputs we have to deal with at the end of this function
			timesRun=0;
			
			//Create an array to store the maskImages output by the roiRemoval function
			ArrayList maskImages = new ArrayList();
			
			//This variable is true as long as we want to keep editing our image
			editImage=true;
	
			//While we want to keep editing
			while(editImage == true) {

				if(IJ.escapePressed() == true) {
					System.exit();
				}
			
				//Ask the user to choose between these choices
				String [] choiceArray = {"Start from the beginning - remove all image edits","Remove ROIs", "Manually threshold the image", "Try an automated thresholding technique", "Smooth the image", "Despeckle the image" };
						
				NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Processing");
				userInputs.addChoice("Watchu wanna do 'bout it?", choiceArray, "Start from the beginning - remove all ROI clearances and thresholding");
				userInputs.showDialog();
			
				int choice = userInputs.getNextChoiceIndex();
		
				//If the user wants to despeckle the image
				if(choice ==5) {

					//We backup the image, run the despeckle
					backup = avg.duplicate();
					IJ.run(avg, "Despeckle", "stack");
		
					backup.show();
		
					//Check user is happy with despeckling, if so then proceed and close the backup, else revert to backup
					despeckleCheck = dialogUserApproval("Despeckling satisfactory?", "Happy with the despeckle?");
			
					if(despeckleCheck == true) {
						backup.close();
					} else {
						avg = replaceWithBackup(avg, backup);
					}

				//If the user wants to smooth the image
				} else if (choice == 4) {

					//Backup the image
					backup = avg.duplicate();

					//Get the user's choices re: smoothing technique and size of smoothing in terms of pixel sizes
					String [] smoothingArray = {"Gaussian Blur 3D", "Median 3D", "Mean 3D", "Minimum 3D", "Maximum 3D", "Variance 3D"};
					String [] despeckleArray = {"Yes, before smoothing", "Yes, after smoothing", "No"};
					String [] pixelSizeArray = {"Pixels to smooth in x: ", "Pixels to smooth in y: ", "Pixels to smooth in z: "};
					ArrayList pixelSizeChoices = new ArrayList();
						
					NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Image Smoothing");
					userInputs.addChoice("Which smoothing technique?", smoothingArray, "Gaussian Blur 3D");
					userInputs.addChoice("Do you want to despeckle the image?", despeckleArray, "Yes, before smoothing");
			
					//Add pixel size fields
					for(fields=0; fields<pixelSizeArray.length; fields++) {
						userInputs.addNumericField(pixelSizeArray[fields], 0,0);
					}
						
					userInputs.showDialog();
			
					//Get pixel sizes
					for(choices=0; choices<pixelSizeArray.length; choices++) {
						pixelSizeChoices.add(userInputs.getNextNumber());
					}
			
					//Get the smoothing method and whether to despeckle before, after, or not
					int smoothingMethod = userInputs.getNextChoiceIndex();
					int despeckleMethod = userInputs.getNextChoiceIndex();

					//If before, run it before smooothing, else run after smoothing
					if(despeckleMethod==0) {
						IJ.run(avg, "Despeckle", "stack");
						IJ.run(avg, ""+smoothingArray[smoothingMethod]+"...", "x="+pixelSizeChoices.get(0)+" y="+pixelSizeChoices.get(1)+" z="+pixelSizeChoices.get(2)+"");
					} else if (despeckleMethod==1) {
						IJ.run(avg, ""+smoothingArray[smoothingMethod]+"...", "x="+pixelSizeChoices.get(0)+" y="+pixelSizeChoices.get(1)+" z="+pixelSizeChoices.get(2)+"");
						IJ.run(avg, "Despeckle", "stack");
					}
			
					//Check user is happy with smoothing, if so then proceed and close the backup, else revert to backup
					smoothFirstCheck = dialogUserApproval("Smoothing satisfactory?", "Happy with the smoothing?");
			
					if(smoothFirstCheck == true) {
						backup.close();
					} else {
						avg = replaceWithBackup(avg, backup);
					}
			
				//If the user chooses to try an automated thresholding technique
				} else if(choice == 3) {
			
					//Backup the input image and run the autoThreshTryAll function on the input
					backup = avg.duplicate();
					autoThreshFinal = autoThreshTryAll(avg);
			
					//If the user is happy with the threhsolding, then run it (if autothreshfinal is a 0 then the user didn't like any of the outputs)
					if(autoThreshFinal != 0) {

						String [] threshNames = {"Default", "Huang", "Huang2", "Intermodes", "IsoData", "Li", "MaxEntropy", "Mean", "MinError(I)", "Minimum", "Moments", "Otsu", "Percentile", "RenyiEntropy", "Shanbhag", "Triangle"};
						//Notice here we run it with a stack histogram, not what we do when trying them (seems to mess with how it gets displayed)
						IJ.run(avg, "Auto Threshold", "method="+threshNames[(autoThreshFinal-1)]+" white stack use_stack_histogram");
			
						//Check if the user is happy
						threshFirstCheck = dialogUserApproval("Threshold satisfactory?", "Happy with the threshold?");				
			
						//If so, we try out skeletonising the threhsolded image
						if(threshFirstCheck == true) {

							//Here we backup the thresholded image
							thresholdedImage = avg.duplicate();
			
							//Here we check the skeleton and edit it if the user wants to
							skelCheckOutput = skeletonChecking(avg, backup, timesRun, maskImages);
			
							//Get the outputs from that function - i.e. whether the user approved the skeleton at first go, and then whether the user approved or
							//disapproved of the skeleton after editing 
							//We also get how many times roiremoval was run during the skeleton editing (this will just be an update on the input timesRun value)
							skeletonFirstCheck = skelCheckOutput.get(0);
							skelGood = skelCheckOutput.get(1);
							timesRun = skelCheckOutput.get(2);
			
							//If user was happy with the skeleton on the first check, or after editing, then exit the editing condition
							if(skelGood ==1 || skeletonFirstCheck == true) {
								editImage = false;
							//Otherwise if the user wasn't happy on the first go or after editing, we replace the skeletonised image with a non-thresholded backup
							//and close the thresholded image that was a backup, i.e., revert to pre-thresholded image
							} else if (skelGood ==0 || skeletonFirstCheck == false) {
								avg = replaceWithBackup(avg, backup);
								thresholdedImage.close();
							}
						//If the user wasn't happy with thresholding the whole stack, replace the thresholded image with the backup
						} else {
							avg = replaceWithBackup(avg, backup);
						}
					//Similarly if during the autothrestryall function the user didn't approve anything, then we replace the avg image with the backup	
					} else {
						avg = replaceWithBackup(avg, backup);
					}
						
				//If the user chooses the manually threhsold the image		
				} else if(choice == 2) {
			
					//Create a backup
					backup = avg.duplicate();
			
					//Run the manual threshlding function on the input where manualHappy is a boolean about whether the user was happy with the manual thresholding
					manualHappy = manualThresholding(avg);
			
					//If the user is happy, we'll try the skeleton editing function
					if(manualHappy == true) {

						//Here we backup the thresholded image
						thresholdedImage = avg.duplicate();
			
						//Here we check the skeleton and edit it if the user wants to
						skelCheckOutput = skeletonChecking(avg, backup, timesRun, maskImages);
			
						//Get the outputs from that function - i.e. whether the user approved the skeleton at first go, and then whether the user approved or
						//disapproved of the skeleton after editing 
						//We also get how many times roiremoval was run during the skeleton editing (this will just be an update on the input timesRun value)
						skeletonFirstCheck = skelCheckOutput.get(0);
						skelGood = skelCheckOutput.get(1);
						timesRun = skelCheckOutput.get(2);
			
						//If user was happy with the skeleton on the first check, or after editing, then exit the editing condition
						if(skelGood ==1 || skeletonFirstCheck == true) {
							editImage = false;
						//Otherwise if the user wasn't happy on the first go or after editing, we replace the skeletonised image with a non-thresholded backup
						//and close the thresholded image that was a backup, i.e., revert to pre-thresholded image
						} else if (skelGood ==0 || skeletonFirstCheck == false) {
							avg = replaceWithBackup(avg, backup);
							thresholdedImage.close();
						}
					//If the user wasn't happy with manual thresholding initially, replace the thresholded image with the backup
					} else {
						avg = replaceWithBackup(avg, backup);
					}
					
				//If the user chooses to remove more ROIs		
				} else if(choice == 1) {
			
					//Create a backup
					backup = avg.duplicate();
						
					//Run the roi removal function
					roiMask = roiRemoval(avg, timesRun);
			
					//Check if the user is happy with the result
					roiRemovalHappy = dialogUserApproval("ROI Removal", "Happy with the ROI removal?");
			
					//If they're happy, we close the backup and add the mask to our arrayList of masks and increase timesRun and hide the mask
					if(roiRemovalHappy == true) {				
						backup.close();
						maskImages.add(roiMask);
						timesRun++;
						roiMask.hide();
					//Otherwise we close the mask and replace the input with the backup
					} else {
						roiMask.close();
						avg = replaceWithBackup(avg, backup);
					}
			
				//If the user wants to start from scratch with the image
				} else if(choice == 0) {	
			
					//Replace the input image with the babyfresh backup and create a new babyfresh backup
					avg = replaceWithBackup(avg, babyFresh);
					babyFresh=avg.duplicate();
				}
			
			}

			//After image editing we check if the user has run the roiRemoval function, and if they have then we have to calculate the volume they've removed
			if(timesRun>0) {
	
				IJ.log("Calculating total volume removed during ROI removal");
				
				//A string to store the list of masks to use when adding them together
				StringBuilder imagesToUse  = new StringBuilder();
				
				//String to store the expression for the image expression parser plugin (i.e. adding the images together or subtracting etc., this plugin can do image calculation but for >2 images)
				StringBuilder expressionToUse = new StringBuilder();
			
				//String to store the correct command i.e. a=[image1] b=[image2] for use with the plugin
				String[] amendedAlphabetArray = new String[26];

				//The plugin uses letters to differentiate images - hence we need these alphabet arrays
				//The plugin also uses uppercase for the expression (i.e. adding or multiplying images) but lowercase for assigning to images
			
				//Character array to store all the upercase alphabet characters
				char[] uppercaseAlpha = new char[26];
				//And one to store the lowercase letters
				char[] lowercaseAlpha = new char[26];
			
				//Populate the uppercaseAlpha array with uppercase letters and lowercase with lower -  fill the amendedAlphabetArray with the lowercase + =[
				for(i = 0; i < 26; i++){
				    uppercaseAlpha[i] = (char)(65 + i);
				    lowercaseAlpha[i] = (char)(97 + i);
				    amendedAlphabetArray[i] = lowercaseAlpha[i]+"=[";
				}
			
				//Loop through the number of times we've run roiRemoval
				for(roisRun = 0; roisRun <timesRun; roisRun++){
					//Get the mask image from the arraylist and its title
					tempSelect = maskImages.get(roisRun);
					tempSelect.show();
					currentImageName = tempSelect.getTitle();
					
					//Get the current amended letter associated with the current roisRun value
					currentLetter = amendedAlphabetArray[roisRun];
					
					//Add a ] to the end of it and attach it to the mask name
					stringToAdd=currentImageName+"] ";
					wholeBit=currentLetter+stringToAdd;
			
					//Add this to the imagesToUse StringBuilder and build up a string of all these
					imagesToUse.append(wholeBit);
			
					//If we aren't at the final roisRun value, put in the uppercase current letter with a +
					if(roisRun!=(timesRun-1)){
						expressionToUse.append(uppercaseAlpha[roisRun]+"+");
					//Else just add the letter without the +	
					} else {
						expressionToUse.append(uppercaseAlpha[roisRun]);
					}
				}
			
				//Turn the StringBuilder values into strings
				String imagesList = imagesToUse.toString();
				String expression = expressionToUse.toString();
			
				//Print the strings to see them
				//IJ.log(imagesList);
				//IJ.log(expression);
			
				//Run the image expression parser using the built strings
				IJ.run("Image Expression Parser (Macro)", "expression="+expression+" "+imagesList+"");
		
				//We get the output of the parser
				parsedImageVirt = IJ.getImage();
				//Then we duplicate it (so that the duplicate is no longer a virtual stack)
				parsedImage=parsedImageVirt.duplicate();
				//Then we close the original
				parsedImageVirt.close();
				//And show the duplicate
				parsedImage.show();
		
				//We then loop through the number of times we've run the roiRemoval and close all the associated mask windows
				for(roisRun = 0; roisRun <timesRun; roisRun++){
					tempSelect = maskImages.get(roisRun);
					tempSelect.close();
				}
		
				//We then invert and 8-bit the parsed image output (the sum of all mask windows)
				IJ.run(parsedImage, "Invert", "stack");
				IJ.run(parsedImage, "8-bit", "");
		
				//Calibrate the parsed image
				IJ.run(parsedImage, "Properties...", "channels="+avgChannels+" slices="+avgSlices+" frames="+avgFrames+" unit=µm pixel_width="+xPxlSize+" pixel_height="+yPxlSize+" voxel_depth="+zPxlSize+"");

				//Calculate the volume occupied by a single voxel using calibrated values of width and depth
				voxelVolume=(xPxlSize*yPxlSize*zPxlSize);

				//Threshold the parsedImage (if we're combining multiple images we need to re-binarise the image)
				IJ.setThreshold(parsedImage, 0.00, 254.0, "Black & White");
				
				//Calculate the volume removed by roi removal
				volumeRemoved = calculateVolRemoved(parsedImage, voxelVolume);
			
				//IJ.log("Calculated space removed by ROIs");	
				//IJ.log("Pixel width: " + IJ.d2s(xPxlSize, 9) + " Pixel depth: " + IJ.d2s(zPxlSize,9) + " Voxel Volume: " + IJ.d2s(voxelVolume,9));
				IJ.log("Volume removed: " + IJ.d2s(volumeRemoved, 9) + "um^3");

				IJ.log("Saving image of removed areas to parent directory");
				IJ.log("Parent directory: " + parentDir);
		
				//Save changes to the parsed image, and close it
				parsedImage.changes = true;
				IJ.saveAsTiff(parsedImage, parentDir+"/masksRemoved.tif");
				parsedImage.close();
	
			//If no roi removals were done
			} else {
				
				IJ.log("No space removed by ROIs");
				//IJ.log("Volume removed: " + IJ.d2s(volumeRemoved,9) + "um^3");
		
			}

			IJ.log("Saving skeleton to parent directory");
			IJ.log("Parent directory: " + parentDir);
		
			//Save our skeleton
			avg.changes = true;
			IJ.saveAsTiff(avg, parentDir+"/skeletonisedImage.tif");
			
			IJ.log("Saving thresholded image to parent directory");
			IJ.log("Parent directory: " + parentDir);
			
			//And save a thresholded image that the skeleton is derived from
			thresholdedImage.changes = true;
			IJ.saveAsTiff(thresholdedImage, parentDir+"/thresholdedImage.tif");

		//If we've done thresholding but not a distance map - this is to open the right files and get the right info in this case for distance map
		//creation and for skeleton coordinates
		} else if (thresholdingDone == 1 && distanceMapDone == 0) { 

			IJ.log("Thresholding done but not distance map");
			IJ.log("Retrieving masks of ROIs removed");

			//Look through the directory for the thresholded image and skeletonised image and open if they exist
			for(File thresholdingCheck:parentFiles) {
				if(thresholdingCheck.getAbsolutePath().toLowerCase().contains("thresholdedimage")) {
					thresholdedImage=IJ.openImage(thresholdingCheck.getAbsolutePath());
				} else if (thresholdingCheck.getAbsolutePath().toLowerCase().contains("skeletonisedimage")) {
					avg = IJ.openImage(thresholdingCheck.getAbsolutePath());

					//Get the dimensions of the calibrated skeletonised image
					avgDimensions = avg.getDimensions();
					avgWidth = avgDimensions[0];
					avgHeight = avgDimensions[1];
					avgChannels = avgDimensions[2];
					avgSlices = avgDimensions[3];
					avgFrames = avgDimensions[4];

				//If we've removed masks, then we open the masksremoved imageand calculate the voxels cleared
				} else if (thresholdingCheck.getAbsolutePath().toLowerCase().contains("masksremoved")) {
					//IJ.log("Getting voxels removed");

					parsedImage = IJ.openImage(thresholdingCheck.getAbsolutePath());
					
					//Calculate the volume occupied by a single voxel using calibrated values of width and depth
					voxelVolume=(xPxlSize*yPxlSize*zPxlSize);

					//Calculate the volume removed by roi removal
					volumeRemoved = calculateVolRemoved(parsedImage, voxelVolume);

				}
			}

		//Otherwise if we've done both a distance map and thresholding - here we get the info we need for skeleton 3d coords
		} else if (thresholdingDone == 1 && distanceMapDone == 1 && skeletonDone == 0) {
			
			IJ.log("Thresholding done, distance map done, but skeleton not analysed");

			//We open our skeletonised image
			for(File thresholdingCheck:parentFiles) {
				if(thresholdingCheck.getAbsolutePath().toLowerCase().contains("skeletonisedimage")) {
					IJ.log(thresholdingCheck.getAbsolutePath());
					avg=IJ.openImage(thresholdingCheck.getAbsolutePath());

					//Get its calibrated dimensions
					avgDimensions = avg.getDimensions();
					avgWidth = avgDimensions[0];
					avgHeight = avgDimensions[1];
					avgChannels = avgDimensions[2];
					avgSlices = avgDimensions[3];
					avgFrames = avgDimensions[4];

					avgVolume = xPxlSize * yPxlSize * zPxlSize * avgHeight * avgWidth * avgSlices;

				//If we've removed rois, calcubate the voxel volume removed
				} else if (thresholdingCheck.getAbsolutePath().toLowerCase().contains("masksremoved")) {
					
					IJ.log("Calculating removed voxels");
					
					parsedImage = IJ.openImage(thresholdingCheck.getAbsolutePath());
					
					//Calculate the volume occupied by a single voxel using calibrated values of width and depth
					voxelVolume=(xPxlSize*yPxlSize*zPxlSize);

					//Calculate the volume removed by roi removal
					volumeRemoved = calculateVolRemoved(parsedImage, voxelVolume);

				} else if (thresholdingCheck.getAbsolutePath().toLowerCase().contains("Dmap")) {
					dMap = IJ.openImage(thresholdingCheck.getAbsolutePath());
				}
			}
		}

		//If we haven't done the distance map
		if (distanceMapDone == 0) {

			IJ.log("Distance map not done");
			IJ.log("Calculating distance map");

			//Use the thresholded image to calculate a 3D euclidian distance map
			thresholdedImage.show();
			thresholdedTitle=thresholdedImage.getTitle();
			tifIndex = thresholdedTitle.indexOf(".tif");
			thresholdedTitleNoTif = thresholdedTitle.substring(0, tifIndex);
	
			IJ.run("3D Distance Map", "map=EDT image="+thresholdedTitleNoTif+" mask=None threshold=1");
			dMap = IJ.getImage();

			IJ.log("Saving distance map in parent directory");
			IJ.log("Parent direction: " + parentDir);

			//Save the distance map and close it
			IJ.saveAsTiff(dMap, parentDir+"/Dmap.tif");

			//Close the thresholded image
			thresholdedImage.changes = false;
			thresholdedImage.close();

		}

		//If the skeleton coordinates haven't been extracted
		if(skeletonDone == 0) {

			volumeAnalysed = avgVolume - volumeRemoved;

			IJ.log("Skeleton not done");
			IJ.log("Analysing skeleton");
			
			//Following analyze skeleton code taken from: https://forum.image.sc/t/3d-image-analyzeskeleton/5404 and edited

			avg.show();
			dmap.show();
			
			//Make sure there are no selections on the skeleton image
			IJ.run(avg, "Select None", "");
	
			// analyze skeleton
			skel = new AnalyzeSkeleton_();
			skel.setup("", avg);
			skelResult = skel.run(AnalyzeSkeleton_.NONE, false, false, null, true, false);
				
			// get graphs (one per skeleton in the image)
			graph = skelResult.getGraph();
				
			//Create 2D arraylist to store the x, y, and z coordinates of each voxel, as well as their associated skeleton number, branch number, and their calibrated values
			ArrayList[][] coordinateValues = new ArrayList[3][3];
			//[0][0] is xCoord, [0][1] is yCoord, [0][2] is zCoord
			//[1][0] is xCoord calibrated, [1][1] is yCoord calibrated, [1[2] is zCoord caibrated
			//[2][0] is skeleton number, [2][1] is branch number, [2][2] is coordinate number
			
			//Fill with arraylists at all indices
			for(i0=0; i0<3; i0++) {
				for(i1=0; i1<3; i1++) {
					coordinateValues[i0][i1] = new ArrayList();
				}
			}
			
			//This is an array of what we need to multiple our coordinates by to get them calibrated (or not)
			double[][] multiplier = {{1,1,1}, {xPxlSize, yPxlSize, zPxlSize}};
			
			// go through all skeletons
			for(i=0 ; i < graph.length; i++ ) {
				listEdges = graph[i].getEdges(); 
				
				// go through all branches - j counts how many branches for each skeleton, our results table won't show data for skeletons without branches or coords
				j=1;
				for( Edge e : listEdges ) {	
			
					//These are arrays of the coordinates of the first and last pixels in the skeleton branch, with [0] being x, [1] y, and [2] z
					double[] firstCoords = {(double) e.getV1().getPoints().get(0).x, (double) e.getV1().getPoints().get(0).y, (double) e.getV1().getPoints().get(0).z};
					double[] lastCoords = {(double) e.getV2().getPoints().get(0).x, (double) e.getV2().getPoints().get(0).y, (double) e.getV2().getPoints().get(0).z};
			
					//Looping through 3 times (the 3 1D in allCoords) - to get the coordinates, calibrated coordinates, and skeleton labels
					for(i0=0; i0<3; i0++) {	
						
						//Looping through 3 times (the 3 2D in allCoords) - to get the x, y, and z (or skel, branch, coord) details
						for(i1=0; i1<3; i1++) {
							
							//If we're on our first 2 1D dimensions (coordinates and calibrated coordinates)
							if(i0<2) {
								
								//Set the first values of allCoords[i0][i1] to the first pixel coordinates and multiply by multplier values 
								coordinateValues[i0][i1].add(firstCoords[i1]*multiplier[i0][i1]);
								
								//Loop through all middle pixels, and set allCoords to those middle pixel values 
								for(i2=1; i2<e.getSlabs().size()+1; i2++) {
									
									//Array to store the middle coordinate values
									double[] middleCoords  = {(double) e.getSlabs().get(i2-1).x, (double) e.getSlabs().get(i2-1).y, (double) e.getSlabs().get(i2-1).z};
									coordinateValues[i0][i1].add(middleCoords[i1]*multiplier[i0][i1]);
								}
								
								//Set the last values to the final pixel values
								coordinateValues[i0][i1].add(lastCoords[i1]*multiplier[i0][i1]);
							
							//If we're on our 3rd 1D dimension - skel, branch, and coord numbers
							} else {
								
								//Set coordNo to 0 to start
								coordNo=0;
								
								//Loop through all the pixel values
								for(i2=0; i2<e.getSlabs().size()+2; i2++) {
									
									//Increase coordNo each time
									coordNo++;
									
									//Create an array to store the skeleton, branch, and coordinate number values and then set these in the allCoords array
									double[] skelInfo = {((double) (i+1)), ((double) j),((double) coordNo)};
									coordinateValues[i0][i1].add(skelInfo[i1]);
								}
							}
						}
					}
			
					//Now we've finished with this branch, increase branch counter j
					j++;
				}
			}
			
			//Run analyze skeleton so we can get out the branch length and euclidean distance of all the skeleton branches
			IJ.run(avg, "Analyze Skeleton (2D/3D)", "prune=[shortest branch] show");
			
			//Get the results table, close it, then set the branch information table as the results table, and get its object reference
			currResults = WindowManager.getWindow("Results");
			currResults.dispose();
			IJ.renameResults("Branch information", "Results");
			ResultsTable branchInfo = ResultsTable.getResultsTable();
			
			//Here we create a double array to store the skeleton number, branch distance, and euclidean distance, from the branch info results table - we also create an int array to store the indices of
			//these columns in the table
			double [][] branchInfoColumns = new double[4][];
			//[0] is skelId, [1] is branch length, [2] is euclidean distance, [3] is for storing the branch number that we calculate 
			int[] branchInfoIndices = {0,1,8}; 
			
			//Loop through, getting the 3 columns from the table and storing them in our 2d double array
			for(i=0; i<4; i++) {
				if(i<3) {
					branchInfoColumns[i] = branchInfo.getColumnAsDoubles(branchInfoIndices[i]);
				} else {
					branchInfoColumns[i] = new double[branchInfoColumns[0].length];
				}
			}
			
			//Create a double value that counts how many branches there are for each skeleton, cast as a double so we can put it into a results table
			double currentNo = 1;
			
			//Loop through all the skeleton values, if we're at the first one, we set the branch number as 1, else we check how the current skeleton compares to the previous one, and if they're teh same,
			//we increase our branch number, otherwise we reset to 1, and store it in our branchInfoColumns [3] array
			for(skelIndex=0; skelIndex<branchInfoColumns[0].length; skelIndex++) {
				if(skelIndex==0) {
					branchInfoColumns[3][skelIndex] = currentNo;
				} else {
					if(branchInfoColumns[0][skelIndex] == branchInfoColumns[0][skelIndex-1]) {
						currentNo = currentNo+1;
					} else {
						currentNo = 1;
					}
					branchInfoColumns[3][skelIndex] = currentNo;
				}
			}
			
			//Get the imagestack of our dmap image
			dmapStack = dmap.getImageStack();
			
			//Create an arraylist to store pixel intensity values
			ArrayList pixelValues = new ArrayList();
			
			//Loop through all skeleton points
			for(i=0; i<coordinateValues[0][0].size(); i++) {
				
				//Get out the pixel value of each skeleton point in the stack and store it in our arraylist
				pixelValues.add(dmapStack.getVoxel((int) coordinateValues[0][0].get(i), (int) coordinateValues[0][1].get(i), (int) coordinateValues[0][2].get(i)));
			}
			
			//Here we create a skeletonValues array to store the data from our radius measurements - this is so that we can sort the skeletonValues
			//array using skeleton, branch, and coordinate number in ascending order, so that we simply have to transpose our radii
			//onto our 3D coords data, rather than having to match the coordinates between arrays
			skeletonValues[] radiiTable = new skeletonValues[coordinateValues[0][0].size()];
			
			//Create a new double array to store our coordinate and radius data in the properly formatted manner
			double[] skeletonValuesToUse = new double[10];
			
			//Loop through all skeleton points
			for(thirdD = 0; thirdD < coordinateValues[0][0].size(); thirdD++) {
				
				//Set the index to fill to 0 to begin
				indexToUse = 0;
				
				//Loop through all data in our coordinateValues array and fill each index of the skeletonValuesToUse array with the data - i.e.
				//xcoord, y coord, z coord, xcal, y cal, zcal, skelNo, branchNo, coordNo, increasing index each time
				for(column = 0; column<3; column++) {
					for(row=0; row<3; row++) {
						skeletonValuesToUse[indexToUse] = coordinateValues[column][row].get(thirdD);
						indexToUse++;
						}
					}
			
				//Once filled with skeleton data, we then add the radius value for that coordinate and fill an index of our radiitable with the values we stored in our skeletonValuestoUse array
				//and we reset indexToUse to 0	
				skeletonValuesToUse[indexToUse] = pixelValues.get(thirdD);
				radiiTable[thirdD] = new skeletonValues(skeletonValuesToUse[0], skeletonValuesToUse[1], skeletonValuesToUse[2], skeletonValuesToUse[3], skeletonValuesToUse[4], skeletonValuesToUse[5], skeletonValuesToUse[6], skeletonValuesToUse[7], skeletonValuesToUse[8], skeletonValuesToUse[9]);
				indexToUse=0;
			}
			
			//Here we sort our radiiTable first by skeletonNo, then by branchNo, then by coordinateNo
			Arrays.sort(radiiTable, ORDER_BY_RULES);
			
			//Here we create a double array to store our now sorted radii, before we fill it with the radii values from our sorted radiiTable
			double[] sortedRadii = new double[pixelValues.size()];
			for(i=0; i<sortedRadii.length; i++) {
				sortedRadii[i] = ((double) radiiTable[i].radius);
			}	
			
			//This variable is to store the runningTotal of coordinate radii so that we can then divide it by the appropriate number
			//of coordinate to get the average radius for a particular branch
			double runningTotal=0;
			
			//Create an arraylist to store the average radius for each branch and the number of coordinates
			ArrayList[] radiiandCoords = new ArrayList[2];
			for(i=0; i<radiiandCoords.length; i++) {
				radiiandCoords[i] = new ArrayList();
			}
			
			//Create double arrays to store the previous coordinate values, and the current coordinate values so we can compare them
			double[] prevValues = new double[4];
			double[] currentValues = new double[3];
			//[0] is skel, [1] is branch, [3] is number of coords, [4] is radii
			
			//Declare the current and previous indices - reason we have to do this is so that when we're on our final index, we can use different indices
			int currentIndex;
			int prevIndex;
			
			//Also declare a writeRadius boolean, which when true causes the code to output the average radius of a unique skeleton/branch combo
			boolean writeRadius = false;
			
			//Here we loop through the length of all our coordinates +1 time since we're comparing two rows to each other, so we need
			//an extra iteration to get the right number of radii
			for(i=0; i<sortedRadii.length+1; i++) {
			
				//If we're not on our first or last index, we get the index of our current values and previous values
				if(i>0 && i<sortedRadii.length) {
					currentIndex = (int) i;
					prevIndex = (int) i-1;
				
				//If we're on our last index, we get the last and second last values, and set writeRadius to true (otherwise we end up with one fewer datapoints if the
				//last index is the same as the second last)
				} else if (i==sortedRadii.length) {
					currentIndex = (int) i-1;
					prevIndex = (int) i-2;
					writeRadius = true;
				}
			
				if(i>0) {
				
					//Looping through 4 times so we can calculate the previous and current skel, branch, coordNo, and radius
					for(i0=0; i0<4; i0++) {	
						
						//if we're in the first two loops, we get our skel, branch, and coordNo from the coordinateValues array - getting values for our current
						//index and the index prior
						if(i0<3) {
							prevValues[i0] = coordinateValues[2][i0].get(prevIndex);
							currentValues[i0] = coordinateValues[2][i0].get(currentIndex);	
						
						//If on the third loop we get our radius from our sorted radii array
						} else {
							prevValues[i0] = sortedRadii[prevIndex];
						}
					}
				
					//Increase the running total of radii using the previous radius and the previous running total
					runningTotal = runningTotal + prevValues[3];
				}
			
				//If the previous values dont match the current values (i.e. we're not on an index for a different branch/skel combo, set writeRadius to true
				if(prevValues[0] != currentValues[0] || prevValues[1] != currentValues[1]) {
					writeRadius = true;
				}
			
				//If our previous skel or previous branch doesnt match our current one, or we're on our last index
				if (writeRadius == true) {
					
					//IJ.log(IJ.d2s(prevValues[0], 9) + " " + IJ.d2s(prevValues[1],9));
					
					//We calculate the number of coordinates with that associated unique skel + branch combo the work out the average radii based on that
					//and store it in our averageRadii arrayList
					noCoords = prevValues[2];
			
					//Fill our arrayList array with the values we want to store - average radius and the number of coordinates
					radiiandCoords[0].add(runningTotal/noCoords);
					radiiandCoords[1].add(noCoords);
			
					//Now that we're done with our current skel/branch combo, we reset running total to 0						
					runningTotal = 0;
			
					//Set writeradius to false again
					writeRadius = false;
				}
			}
			
			//Create a new results table to show all the branch info
			finalTable = new ResultsTable();
			
			String[] finalTableHeaders = {"Skeleton Number", "Branch Number", "Number of Coordinates", "Radius", "Branch Length", "Euclidean Distance"};
			int[] indicesForFinalTable = {0,3,1,0,1,2};
			
			//Loop through all the branch summary info, setting the skeleton, branch, distance, and euclidean distance from the original
			//analyze skeleton results table, and setting the number of coordinates and radii from the calculated values
			for(i=0; i<branchInfoColumns[0].length; i++) {
				for(i0=0; i0<finalTableHeaders.length; i0++) {
					if(i0==2 || i0 ==3) {
						finalTable.setValue(finalTableHeaders[i0], i, radiiandCoords[indicesForFinalTable[i0]].get(i));
					} else {
						finalTable.setValue(finalTableHeaders[i0], i, branchInfoColumns[indicesForFinalTable[i0]][i]);
					}
				}
			}

			finalTable.setValue("Image Volume", 0, avgVolume);
			finalTable.setValue("Volume Removed", 0, volumeRemoved);
			finalTable.setValue("Volume Analysed", 0, volumeAnalysed);
			
			//Display the final table as the branch information table
			//finalTable.show("Branch Details");
			finalTable.save(parentDir+"/Branch Details.xls");

			//Create a new results table to output the 3D skeleton information
			rt = new ResultsTable();
			
			//Create a 2D string array of headers we'll use on our results table
			String[][] resultsHeaders = {{"X Coordinate", "Y Coordinate", "Z Coordinate"}, {"Calibrated X", "Calibrated Y", "Calibrated Z"}, {"Skeleton Number", "Branch Number", "Coordinate Number"}};
			
			//Go through all the table columns and rows, and fill our results table with the appropriate header and values
			for(columnAdding = 0; columnAdding<3; columnAdding++) {
				for(rowAdding=0; rowAdding<3; rowAdding++) {
					for(thirdD = 0; thirdD<coordinateValues[columnAdding][rowAdding].size(); thirdD++) {
						rt.setValue(resultsHeaders[columnAdding][rowAdding], thirdD, (double) coordinateValues[columnAdding][rowAdding].get(thirdD));
						
						//If we're adding our last data to the table, we can now add our radii data as well
						if(columnAdding==2 && rowAdding ==2) {
							rt.setValue("Radius", thirdD, sortedRadii[thirdD]);
						}
					}
				}
			}
			
			//rt.show("3D Coordinates");
			rt.save(parentDir+"/3D Coords.xls");
			
			//Putting this bit any earlier seems to mess with analyze skeleton..so be careful with it
			if( WindowManager.getWindow("Tagged skeleton") != null) {
				WindowManager.getWindow("Tagged skeleton").dispose();
			}
	
		}
		
		IJ.log("Image processed");
	}
}