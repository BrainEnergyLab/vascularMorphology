import ij.IJ; //Import this so that we can use imageJ to open the image
import ij.gui.GenericDialog; //Import so we can create dialog boxes
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.ImagePlus; //Import to allow us to create or alter images
import ij.WindowManager; //Import to allow us to manager windows
import ij.measure; //Import so we can measure things

//This is basically declaring a function
//Argsin are the directory to search, the substring to search for, and an arraylist declared outside the function to fill with matching locations
public static listFilesAndFilesSubDirectories(String directoryName, String substring, ArrayList output) {

	//Here we declare our folder as a file variable for our directory and create a file array of the files within folder
	File folder = new File(directoryName);
	File [] listOfFiles = folder.listFiles();
	
	//Loop through the files in the file list
	for (File file:listOfFiles) {
		//If the file we're checking is a file and not a directory
		if (file.isFile()) {
			//And if it contains the substring we're interested in within its full path
			if(file.getAbsolutePath().contains(substring)) {
				//We store the full path in the output ArrayList;
				String stringForm = file.getAbsolutePath();
				File fileForm = new File(stringForm);
				fileLocations.add(fileForm);
				//imp=IJ.openImage(file.getAbsolutePath);
				//imp.show();
			}
		//If the file we're checking is a directory, then we run the whole thing on that directory
		} else if (file.isDirectory()) {
			listFilesAndFilesSubDirectories(file.getAbsolutePath(), substring, fileLocations);           
		}
	}

	//Here we convert out ArrayList to a string array and return it
	File[] arrayForm = fileLocations.toArray(new File[0]);
	//String [] test = new String[fileLocations.size()];
	//test=fileLocations.toArray(test);
	//System.out.println(fileLocations.size());
	//System.out.println(test.length);
	//String [] test = fileLocations.toArray(new String[fileLocations.size()]);
	return arrayForm;
}

//Example inputs for the function (called a method in java?)
//String dir = "E:/Dropbox (Brain Energy Lab)/Everything/2P data/Devin/";
String dir = "/Users/Devin/Downloads";
String toFind = "WideFOV";

//Declare the arrraylist to fill outside the function
ArrayList fileLocations = new ArrayList();

//Here we return the output of the method into a file array
System.out.println("Start");
File [] output = listFilesAndFilesSubDirectories(dir, toFind, fileLocations);
System.out.println("End");

//Here we create a dialog box for user input
//choiceArray is a list of channels the user can select
//channelNames are the associated substrings with those channels
String [] choiceArray =  {"1", "2", "3", "4"};
String [] channelNames = {"ch_1", "ch_2", "ch_3", "ch_4"};

GenericDialog userInputs = new GenericDialog("User Inputs");
userInputs.addNumericField("Number of frames per plane: ", 0, 0);
userInputs.addChoice("Which channel to use", choiceArray, "2");
userInputs.showDialog();

//Retrive the choices as integers, or as a string in the case of channel
int choice = userInputs.getNextChoiceIndex();
int FperZ = userInputs.getNextNumber();
String channel = channelNames[choice];

//Here we go through our list of file locations and open ones that include ch_2 (i.e. they are TexasRed) if selected channel is 2
for (File file:output) {
	if(file.getAbsolutePath().contains(channel)) {
		imp=IJ.openImage(file.getAbsolutePath());
		String name = imp.getTitle();
		
		//imp.show();
		//String [] test = WindowManager.getImageTitles();
		//System.out.println(test[0]);
		//System.out.println(name);
		//here = WindowManager.getImage(name);
		//System.exit();	
		
		//Here we register the open image then grouped z project it according to the user input of how many frames per Z were taken
		//IJ.run(imp, "MultiStackReg", ""+name+" action_1=Align file_1=[] stack_2=None action_2=Ignore file_2=[] transformation=Translation");
		IJ.run(imp, "Grouped Z Project...", "projection=[Average Intensity] group="+FperZ+"");
		
		//Here we get the averaged image and set it as avg
		String avgName = "AVG_"+name;
		avg = WindowManager.getImage(avgName);
		
		//Turn avg into an 8 bit image and median smooth it
		IJ.run(avg, "8-bit", "");
		IJ.run(avg, "Median 3D...", "x=2 y=2 z=2");
		
		//Create a dialog to ask the user whether they want to manually remove ROIs
		GenericDialog userInputs = new GenericDialog("Cleaning image");
		userInputs.addCheckbox("Do you want to manually remove ROIs from the image?", false);
		userInputs.showDialog();

		//Get the checkbox (which returns a vector so we have to get an index of it)
		roiChoice = userInputs.getCheckboxes();
		removeROIs = roiChoice.get(0);
		//test = String.valueOf(removeROIs);
		//IJ.log(test);

		//Create dynamic arrays to fill with the count of ROIs we clear as well as their areas and depths
		ArrayList roiNamesArray = new ArrayList();
		ArrayList twoDAreaArray = new ArrayList();
		ArrayList sliceAreaArray = new ArrayList();

		//Create variable to count how many ROIs we clear
		int count = 1;

		//Get the pixel sizes and unit of calibration of the avg image
		pxlWidth = avg.Calibration.pixelWidth;
		pxlDepth = avg.Calibration.pixelDepth;
		unit = avg.Calibration.getUnit();

		//Get the area of the whole image in pixels, and it's slice number
		wholeArea=avg.getStatistics().area;
		totalSlices=avg.getNSlices();
		
		//If the checkbox was true, then enter the loop for removing bits of the image
		while (removeROIs.getState() == true) {
			
			//Show the avg image then ask the user for input
			avg.show();
			new WaitForUserDialog("ROI selection", "Draw a ROI to exclude from image if desired, and set the stack to the slice you want to start at").show();
			
			//Get the roi drawn as well as the number of the slice set - and get the area of the roi
			int startSlice = avg.getSlice();

			//Get the slice chosen by the user as the end and calculate difference
			new WaitForUserDialog("ROI selection", "Set the slice where you want the ROI to end").show();
			int endSlice = avg.getSlice();

			//If the endslice is set before the start then we go back to the start of the loop and show an error message
			if(endSlice<startSlice) {
				
				new WaitForUserDialog("Slice error", "End slice was set before the start slice").show();
				
				} else {

				//Otherwise we get the roi area and slice depth
				TestROI = avg.getRoi();
				roiStats = TestROI.getStatistics();
				twoDArea = roiStats.area;

				sliceArea=endSlice-startSlice+1;
				
				//Loop through the slices from start to end, each time clearing the area within the ROI
				IJ.log(Integer.toString(startSlice) + " " + Integer.toString(endSlice));
				for (int clearSlice = startSlice; clearSlice <= endSlice; clearSlice++) {
					avg.setSlice(clearSlice);
					IJ.run(avg, "Clear", "slice");
					//IJ.log(Integer.toString(clearSlice));
				}

				//Add our count, area, and depth to our dyanmic arrays
				roiNamesArray.add(count);
				twoDAreaArray.add(twoDArea);
				sliceAreaArray.add(sliceArea);
		
		
				//IJ.log("2D Area: " + IJ.d2s(twoDArea, 9) + " Slice Area: " + Integer.toString(sliceArea) + " Pixel Width: " + IJ.d2s(pxlWidth, 9) + " Pixel Depth: " + IJ.d2s(pxlDepth, 9) + " Unit: " + unit);
			
				//Create a dialog to ask the user whether they want to manually remove any more ROIs - if yes we repeat the loop
				GenericDialog userInputs = new GenericDialog("Cleaning image");
				userInputs.addCheckbox("Do you want to manually remove another ROI from the image?", false);
				userInputs.showDialog();
	
				//Get the checkbox (which returns a vector so we have to get an index of it)
				roiChoice = userInputs.getCheckboxes();
				removeROIs = roiChoice.get(0);
				//test = String.valueOf(removeROIs);
				//IJ.log(test);

				//Increase the value of count by 1
				count++;
			}
		}

		//Display the arrays from ROI clearing
		System.out.println("roiNamesArray contains: " + roiNamesArray.toString());  
		System.out.println("twoDAreaArray contains: " + twoDAreaArray.toString());  
		System.out.println("sliceAreaArray contains: " + sliceAreaArray.toString());  

		//Ask the user to check the display - for debugging
		new WaitForUserDialog("Check prints", "Check the values printed").show();

		//Clear the selection of the last ROI
		IJ.run(avg, "Select None", "");
		
		avgNameSmooth = avg.duplicate();
		String dupName = avgNameSmooth.getTitle();
		IJ.run(avgNameSmooth, "Auto Threshold", "method=Otsu white stack use_stack_histogram");
		
		//Issue here with thresholding - not working for all images, need to build in some code here so the user can pick the thresholding that works best
		avgNameSmooth.show();
		new WaitForUserDialog("Check prints", "Check the thresh").show();
		IJ.run(avgNameSmooth, "Skeletonize (2D/3D)", "");
		avgNameSmooth.show();
		//IJ.run(avgNameSmooth, "Analyze Skeleton (2D/3D)", "prune=[lowest intensity voxel] show display original_image="+dupName+"");
		IJ.run(avgNameSmooth, "Analyze Skeleton (2D/3D)", "prune=[shortest branch] show display");
		
		//test.close();

		tifIndex = dupName.indexOf(".tif");
		String skeletonName = dupName.substring(0, tifIndex) + "-labeled-skeletons";
		skelWindow = WindowManager.getImage(skeletonName);
		//skelWindow.close();

		//String [] test = WindowManager.getImageTitles();
		//System.out.println(skeletonName);
		//System.out.println(test[0]);
		//System.out.println(test[1]);
		//System.out.println(test[2]);
		//System.out.println(test[3]);
		//System.out.println(test[4]);
		
		System.exit();	
		}
}
