import ij.IJ; //Import this so that we can use imageJ to open the image
import ij.gui.GenericDialog; //Import so we can create dialog boxes
import ij.gui.WaitForUserDialog; //Import to allow us to wait for user input
import ij.gui.NonBlockingGenericDialog; //Import to allow us to create non blocking dialogs
import ij.ImagePlus; //Import to allow us to create or alter images
import ij.WindowManager; //Import to allow us to manager windows
import ij.measure; //Import so we can measure things
import ij.plugin.Duplicator; //Import so we can create substacks using the duplicator
import ij.process.ImageProcessor //Import so we can invert the LUT after thresholding

//This is basically declaring a function
//Argsin are the directory to search, the substring to search for, and an arraylist declared outside the function to fill with matching locations
public static listFilesAndFilesSubDirectories(String directoryName, String substring, ArrayList fileLocations) {

	//Here we declare our folder as a file variable for our directory and create a file array of the files within folder
	File folder = new File(directoryName);
	File [] listOfFiles = folder.listFiles();
	
	//Loop through the files in the file list
	for (File file:listOfFiles) {
		//If the file we're checking is a file and not a directory
		if (file.isFile()) {
			//And if it contains the substring we're interested in within its full path
			if(file.getAbsolutePath().contains(substring)) {
				//We store the full path in the output ArrayList;
				String stringForm = file.getAbsolutePath();
				File fileForm = new File(stringForm);
				fileLocations.add(fileForm);
				//imp=IJ.openImage(file.getAbsolutePath);
				//imp.show();
			}
		//If the file we're checking is a directory, then we run the whole thing on that directory
		} else if (file.isDirectory()) {
			listFilesAndFilesSubDirectories(file.getAbsolutePath(), substring, fileLocations);           
		}
	}

	//Here we convert out ArrayList to a string array and return it
	File[] arrayForm = fileLocations.toArray(new File[0]);
	//String [] test = new String[fileLocations.size()];
	//test=fileLocations.toArray(test);
	//System.out.println(fileLocations.size());
	//System.out.println(test.length);
	//String [] test = fileLocations.toArray(new String[fileLocations.size()]);
	return arrayForm;
}

//This asks the user if they wish to remove ROIs from the image, and outputs the area of ROI removed and over what range of slices
//Argsin are just the title of the image to be ROI edited
public static roiRemoval(String imageTitle) {

	//Here we create a 2D arraylist to dynamically store out roiNames, 2D area, and slice area	
	ArrayList[][] table = new ArrayList[1][3];
	table[0][0] = new ArrayList(); // add another ArrayList object to [0,0] this is for roiNames
	table[0][1] = new ArrayList(); // add another ArrayList object to [0,1] this is for twoDArea
	table[0][2] = new ArrayList(); // add another ArrayList object to [0,2] this is for sliceArea
	
	//Create a dialog to ask the user whether they want to manually remove ROIs
	GenericDialog userInputs = new GenericDialog("Cleaning image");
	userInputs.addCheckbox("Do you want to manually remove ROIs from the image?", false);
	userInputs.showDialog();

	//Get the checkbox (which returns a vector so we have to get an index of it)
	roiChoice = userInputs.getCheckboxes();
	removeROIs = roiChoice.get(0);
	//test = String.valueOf(removeROIs);
	//IJ.log(test);

	//Create variable to count how many ROIs we clear
	int count = 1;

	//Set the image we're working with to a variable
	avg = WindowManager.getImage(imageTitle);
		
	//If the checkbox was true, then enter the loop for removing bits of the image
	while (removeROIs.getState() == true) {
			
		//Show the avg image then ask the user for input
		avg.show();
		new WaitForUserDialog("ROI selection", "Draw a ROI to exclude from image if desired, and set the stack to the slice you want to start at").show();
			
		//Get the roi drawn as well as the number of the slice set - and get the area of the roi
		int startSlice = avg.getSlice();

		//Get the slice chosen by the user as the end and calculate difference
		new WaitForUserDialog("ROI selection", "Set the slice where you want the ROI to end").show();
		int endSlice = avg.getSlice();

		//If the endslice is set before the start then we go back to the start of the loop and show an error message
		if(endSlice<startSlice) {
				
			new WaitForUserDialog("Slice error", "End slice was set before the start slice").show();
			
			} else {

			//Otherwise we get the roi area and slice depth
			TestROI = avg.getRoi();
			roiStats = TestROI.getStatistics();
			twoDArea = roiStats.area;

			sliceArea=endSlice-startSlice+1;
				
			//Loop through the slices from start to end, each time clearing the area within the ROI
			IJ.log(Integer.toString(startSlice) + " " + Integer.toString(endSlice));
			for (int clearSlice = startSlice; clearSlice <= endSlice; clearSlice++) {
				avg.setSlice(clearSlice);
				IJ.run(avg, "Clear", "slice");
				//IJ.log(Integer.toString(clearSlice));
			}

			//Add our count, area, and depth to our dyanmic arrays
			table[0][0].add(count);
			table[0][1].add(twoDArea);
			table[0][2].add(sliceArea);
		
			//IJ.log("2D Area: " + IJ.d2s(twoDArea, 9) + " Slice Area: " + Integer.toString(sliceArea) + " Pixel Width: " + IJ.d2s(pxlWidth, 9) + " Pixel Depth: " + IJ.d2s(pxlDepth, 9) + " Unit: " + unit);
			
			//Create a dialog to ask the user whether they want to manually remove any more ROIs - if yes we repeat the loop
			GenericDialog userInputs = new GenericDialog("Cleaning image");
			userInputs.addCheckbox("Do you want to manually remove another ROI from the image?", false);
			userInputs.showDialog();
	
			//Get the checkbox (which returns a vector so we have to get an index of it)
			roiChoice = userInputs.getCheckboxes();
			removeROIs = roiChoice.get(0);
			//test = String.valueOf(removeROIs);
			//IJ.log(test);

			//Increase the value of count by 1
			count++;
		}
	}

	//Display the arrays from ROI clearing
	System.out.println("roiNamesArray contains: " + table[0][0].toString());  
	System.out.println("twoDAreaArray contains: " + table[0][1].toString());  
	System.out.println("sliceAreaArray contains: " + table[0][2].toString());  

	//Ask the user to check the display - for debugging
	new WaitForUserDialog("Check prints", "Check the values printed").show();

	//Clear the selection of the last ROI
	IJ.run(avg, "Select None", "");

	//Return our 2D arraylist
	return table;
	
}

//Example inputs for the function (called a method in java?)
String dir = "E:/Dropbox (Brain Energy Lab)/Everything/2P data/Devin/";
//String dir = "/Users/Devin/Downloads";
String toFind = "WideFOV";

//Declare the arrraylist to fill outside the function
ArrayList fileLocations = new ArrayList();

//Here we return the output of the method into a file array
System.out.println("Start");
File [] output = listFilesAndFilesSubDirectories(dir, toFind, fileLocations);
System.out.println("End");

//Here we create a dialog box for user input
//choiceArray is a list of channels the user can select
//channelNames are the associated substrings with those channels
String [] choiceArray =  {"1", "2", "3", "4"};
String [] channelNames = {"ch_1", "ch_2", "ch_3", "ch_4"};

GenericDialog userInputs = new GenericDialog("User Inputs");
userInputs.addNumericField("Number of frames per plane: ", 0, 0);
userInputs.addChoice("Which channel to use", choiceArray, "2");
userInputs.showDialog();

//Retrive the choices as integers, or as a string in the case of channel
int choice = userInputs.getNextChoiceIndex();
int FperZ = userInputs.getNextNumber();
String channel = channelNames[choice];

//Here we go through our list of file locations and open ones that include ch_2 (i.e. they are TexasRed) if selected channel is 2
for (File file:output) {
	if(file.getAbsolutePath().contains(channel)) {
		imp=IJ.openImage(file.getAbsolutePath());
		String name = imp.getTitle();
		
		//imp.show();
		//String [] test = WindowManager.getImageTitles();
		//System.out.println(test[0]);
		//System.out.println(name);
		//here = WindowManager.getImage(name);
		//System.exit();	
		
		//Here we register the open image then grouped z project it according to the user input of how many frames per Z were taken
		//IJ.run(imp, "MultiStackReg", ""+name+" action_1=Align file_1=[] stack_2=None action_2=Ignore file_2=[] transformation=Translation");
		IJ.run(imp, "Grouped Z Project...", "projection=[Average Intensity] group="+FperZ+"");
		
		//Here we get the averaged image and set it as avg
		String avgName = "AVG_"+name;
		avg = WindowManager.getImage(avgName);
		
		//Turn avg into an 8 bit image and median smooth it
		IJ.run(avg, "8-bit", "");
		//IJ.run(avg, "Median 3D...", "x=2 y=2 z=2");

		//Get the pixel sizes and unit of calibration of the avg image
		pxlWidth = avg.Calibration.pixelWidth;
		pxlDepth = avg.Calibration.pixelDepth;
		unit = avg.Calibration.getUnit();
	
		//Get the area of the whole image in pixels, and it's slice number
		wholeArea=avg.getStatistics().area;
		totalSlices=avg.getNSlices();

		//System.exit();	

		//Here we run the roi removal on our averaged, smoothed image, and output a table with the roi details
		ArrayList[][] roiDetails = roiRemoval(avgName);

		//Here we duplicate our smoothed, roi cleaned image
		//avgNameSmooth = avg.duplicate();
		//String dupName = avgNameSmooth.getTitle();

		//Here we create a 20 slice substack of our smoothed, cleaned image, so that we can try out the auto thresholds on it
		threshTest = new Duplicator().run(avg, 1, 20);
		threshTest.show();

		//This runs the try all action for the auto threshold method
		IJ.run(threshTest, "Auto Threshold", "method=[Try all] white stack");
		threshStack = WindowManager.getImage("Stack");

		//These string arrays are for choosing which thresholding method to use
		String [] threshChoice =  {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16"};
		String [] threshNames = {"Default", "Huang", "Huang2", "Intermodes", "IsoData", "Li", "MaxEntropy", "Mean", "MinError(I)", "Minimum", "Moments", "Otsu", "Percentile", "RenyiEntropy", "Shanbhag", "Triangle"};
		
		//Create a non-blocking dialog so the user can still check the image whilst choosing
		NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Auto Threshold Choice");
		userInputs.addChoice("Which panel worked the best?", threshChoice, "1");
		userInputs.addCheckbox("Tick if none of them are any good", false);
		
		userInputs.showDialog();

		//Close the stack of threshold test
		threshStack.close();

		//Get the choices from the dialog box
		int choice = userInputs.getNextChoiceIndex();
		String threshSelected = threshNames[choice];
		
		goodThresh = userInputs.getCheckboxes();
		goodThreshChoice = goodThresh.get(0);	

		//If the user has selected that the automatic thresholding is no good
		if(goodThreshChoice.getState() == true) {

			//Close the threshold test image
			threshTest.close();

			//Ask the user if they want to clean up the image more, and if they want to manually threshold
			NonBlockingGenericDialog userInputs = new NonBlockingGenericDialog("Thresholding issues");
			userInputs.addCheckbox("Do you want to remove more noise from the image?", false);
			userInputs.addCheckbox("Do you want to threshold manually?", false);

			userInputs.showDialog();

			//Get the choices
			checkChoices = userInputs.getCheckboxes();
			redoNoiseRemoval = checkChoices.get(0);
			manuallyThreshold = checkChoices.get(1);

			//If chosen to remove more noise, run the roiRemoval and get out the roi info
			if(redoNoiseRemoval.getState() == true) {
				ArrayList[][] roiDetailsBadThresh = roiRemoval(avgName);	
			}

			//If we need to manually threshold, run it
			if(manuallyThreshold.getState() == true) {
				IJ.setAutoThreshold(avg, "Default");
				new WaitForUserDialog("Manual thresholding", "Manually threshold the image then proceed").show();

				//If after thresholding the image has an inverted LUT, we flip it
				if(avg.isInvertedLut() == true) {
					IJ.run(avg, "Invert LUT", "");
				}

				//Now we check that the image foreground and background are correctly set
				new WaitForUserDialog("Check image", "Make sure that vessels are in white on a black background, then proceed").show();
				
			}
			
			//Need to now run through the autothresholding again if the user chose not to manually threshold

			System.exit();	

			//We now need to implement whatever comes as a result of these choices - loop through this sequence so we can constantly edit the image?
			
			}
	
		IJ.run(avgNameSmooth, "Auto Threshold", "method="+threshSelected+" white stack");
		
		//Issue here with thresholding - not working for all images, need to build in some code here so the user can pick the thresholding that works best
		avgNameSmooth.show();
		new WaitForUserDialog("Check prints", "Check the thresh").show();
		IJ.run(avgNameSmooth, "Skeletonize (2D/3D)", "");
		avgNameSmooth.show();
		//IJ.run(avgNameSmooth, "Analyze Skeleton (2D/3D)", "prune=[lowest intensity voxel] show display original_image="+dupName+"");
		IJ.run(avgNameSmooth, "Analyze Skeleton (2D/3D)", "prune=[shortest branch] show display");
		
		//test.close();

		tifIndex = dupName.indexOf(".tif");
		String skeletonName = dupName.substring(0, tifIndex) + "-labeled-skeletons";
		skelWindow = WindowManager.getImage(skeletonName);
		//skelWindow.close();

		//String [] test = WindowManager.getImageTitles();
		//System.out.println(skeletonName);
		//System.out.println(test[0]);
		//System.out.println(test[1]);
		//System.out.println(test[2]);
		//System.out.println(test[3]);
		//System.out.println(test[4]);
		
		System.exit();	
		}
}
